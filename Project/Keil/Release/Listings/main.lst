C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Release\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\main.lst) O
                    -BJECT(.\Release\Objects\main.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    main.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    01-05-2021
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2021 HUGE-IC</center></h2>
  12           *
  13           * 版权说明后续补上
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "include.h"
  20          #include <stdio.h>
  21          
  22          #include "user_config.h"
  23          
  24          volatile bit_flag flag1 = {0};
  25          volatile bit_flag flag2 = {0};
  26          
  27          
  28          
  29          // =================================================================
  30          // 充电控制相关变量                                                 //
  31          // =================================================================
  32          volatile u16 bat_adc_val;                                           // 电池电压检测脚采集到的ad值
  33          volatile u16 charging_adc_val;                                      // 充电电压检测脚采集的ad值
  34          volatile u16 current_adc_val;                                       // 充电电流检测脚采集的ad值
  35          volatile u8 flag_is_charging_adjust_time_come = 0;                  // 调节充电的时间到来
  36          volatile u8 cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE; // 控制充电的PWM状态
  37          volatile u8 cur_charge_phase = CUR_CHARGE_PHASE_NONE;               // 记录当前充电阶段 
  38          
  39          volatile u32 light_adjust_time_cnt = 0;    // 调节灯光的时间计数，暂定为每1s加一
  40          volatile u8 light_ctl_phase_in_rate_1 = 1; // 在放电速率M1时，使用到的变量，在计算公式里面用作系数，每次唤
             -醒时需要初始化为1 
  41          
  42          // =================================================================
  43          // 指示灯控制相关变量                                               //
  44          // =================================================================
  45          volatile u8 cur_initial_discharge_gear = 5; // 初始放电挡位（需要记忆）
  46          volatile u8 cur_discharge_rate = 2;         // 初始放电速率（需要记忆）
  47          volatile u8 cur_led_mode;                   // 当前的LED模式
  48          volatile u8 cur_led_gear;                   // 当前led挡位
  49          volatile u8 last_led_gear;                  // 上次led挡位
  50          volatile u8 cur_led_gear_in_charging;       // 充电指示，对应的挡位
  51          volatile bit flag_is_in_setting_mode = 0;   // 是否处于设置模式
  52          // 特殊的LED模式，退出时间计数
C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 2   

  53          volatile u16 led_mode_setting_exit_times_cnt = 0;
  54          // volatile u16 special_led_mode_times_cnt = 0;
  55          //
  56          
  57          // =================================================================
  58          // 主灯光控制相关变量                                               //
  59          // =================================================================
  60          // TODO：3260使用16位寄存器，7361使用8位寄存器，要进行适配修改
  61          volatile u16 cur_light_pwm_duty_val = 0;    // 当前灯光对应的占空比值
  62          volatile u16 expect_light_pwm_duty_val = 0; // 期望调节到的、灯光对应的占空比值
  63          volatile u8 flag_is_light_adjust_time_come = 0; // 调节灯光的时间到来，目前为1s
  64          volatile u8 flag_is_light_pwm_duty_val_adjust_time_come = 0;// 灯光占空比值调节时间到来
  65          
  66          
  67          void led_pin_config(void)
  68          {
  69   1          P1_MD0 &= ~GPIO_P11_MODE_SEL(0x03);
  70   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x01);
  71   1          FOUT_S11 = GPIO_FOUT_AF_FUNC;
  72   1          P11 = 0; // 如果不给初始值，上电之后，指示灯会闪一下
  73   1      
  74   1          P1_MD0 &= ~GPIO_P12_MODE_SEL(0x03);
  75   1          P1_MD0 |= GPIO_P12_MODE_SEL(0x01);
  76   1          FOUT_S12 = GPIO_FOUT_AF_FUNC;
  77   1          P12 = 0;
  78   1      
  79   1          P1_MD0 &= ~GPIO_P13_MODE_SEL(0x03);
  80   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x01);
  81   1          FOUT_S13 = GPIO_FOUT_AF_FUNC;
  82   1          P13 = 0;
  83   1      
  84   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03);
  85   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  86   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;
  87   1          P14 = 0;
  88   1      
  89   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03);
  90   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);
  91   1          FOUT_S15 = GPIO_FOUT_AF_FUNC;
  92   1          P15 = 0;
  93   1      }
  94          
  95          /* 
  96              变量、参数，初始化
  97          
  98              如果是第一次上电，需要读出存放的数据
  99          */
 100          void param_init(void)
 101          {
 102   1          light_ctl_phase_in_rate_1 = 1;
 103   1      }
 104          
 105          /**
 106           * @brief  Main program.
 107           * @param  None
 108           * @retval None
 109           */
 110          void main(void)
 111          {
 112   1          // 看门狗默认打开, 复位时间2s
 113   1          WDT_KEY = WDT_KEY_VAL(0xDD); //  关闭看门狗 (如需配置看门狗请查看“WDT\WDT_Reset”示例)
 114   1      
C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 3   

 115   1          system_init();
 116   1      
 117   1          // 关闭HCK和HDA的调试功能
 118   1          WDT_KEY = 0x55;  // 解除写保护
 119   1          IO_MAP &= ~0x01; // 清除这个寄存器的值，实现关闭HCK和HDA引脚的调试功能（解除映射）
 120   1          WDT_KEY = 0xBB;  // 写一个无效的数据，触发写保护
 121   1      
 122   1          uart0_config();
 123   1          my_debug_led_config();
 124   1      
 125   1          timer0_config();
 126   1          timer1_pwm_config(); // 控制充电的PWM
 127   1          timer1_pwm_disable();
 128   1          timer2_pwm_config(); // 控制灯光的pwm
 129   1          timer2_pwm_disable();
 130   1      
 131   1          // timer1_set_pwm_high_feq();
 132   1          // TODO: 7361不用加这个引脚配置:
 133   1          led_pin_config();
 134   1      
 135   1          // 红外接收引脚：
 136   1          P2_MD0 &= ~(GPIO_P23_MODE_SEL(0x03)); // 输入模式
 137   1          P2_PU |= GPIO_P23_PULL_UP(0x01);      // 上拉
 138   1      
 139   1          adc_config();
 140   1      
 141   1          printf("sys reset\n"); // 打印至少占用1012字节空间
 142   1      
 143   1          // TODO:
 144   1          // 上电后，需要先点亮红色指示灯，再变为电池电量指示模式
 145   1          // LED_1_ON();
 146   1          // delay_ms(1000);
 147   1      
 148   1          // cur_led_mode = CUR_LED_MODE_INITIAL_DISCHARGE_GEAR;
 149   1      
 150   1      #if 0
                  cur_led_mode = CUR_LED_MODE_BAT_INDICATOR; // 电池电量指示模式
                  cur_initial_discharge_gear = 5;
                  cur_discharge_rate = 3;
              #endif
 155   1      
 156   1          // cur_led_mode = CUR_LED_MODE_CHARGING;
 157   1      
 158   1          // bat_adc_val = 2000;
 159   1          // led_status_refresh();
 160   1          // cur_led_mode = CUR_LED_MODE_BAT_INDICATOR;
 161   1      
 162   1          param_init();
 163   1      
 164   1          led_mode_alter(CUR_LED_MODE_BAT_INDICATOR); // 电池电量指示模式
 165   1          light_init();
 166   1      
 167   1          while (1)
 168   1          {
 169   2      #if 1
 170   2              // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
 171   2              // bat_adc_val = adc_getval(); // 采集电池电压对应的ad值
 172   2              // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
 173   2              // adc_sel_pin_charge(CUR_ADC_REF_3_0_VOL);
 174   2              // charging_adc_val = adc_getval();
 175   2              // adc_sel_pin(ADC_PIN_DETECT_CURRENT);
 176   2              // current_adc_val = adc_getval(); // 采集流入电池的电流对应的ad值
C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 4   

 177   2      
 178   2              // printf("current_adc_val %u\n", current_adc_val);
 179   2      
 180   2              // adc_update_bat_adc_val();
 181   2              charge_handle();
 182   2              ir_handle(); // 函数内部会判断是否在充电，如果在充电则退出
 183   2      
 184   2              // 如果当前正在充电，但是指示灯没有切换到充电指示模式，则切换：
 185   2              if (CUR_CHARGE_PHASE_NONE != cur_charge_phase)
 186   2              {
 187   3                  if (cur_led_mode != CUR_LED_MODE_CHARGING &&
 188   3                      cur_led_mode != CUR_LED_MODE_OFF)
 189   3                  {
 190   4                      led_mode_alter(CUR_LED_MODE_CHARGING);
 191   4                  }
 192   3      
 193   3                  // TODO：需要关闭主灯光
 194   3                  // timer2_pwm_disable(); 
 195   3                  LIGHT_OFF();
 196   3              } // if (CUR_CHARGE_PHASE_NONE != cur_charge_phase)
 197   2              else // CUR_CHARGE_PHASE_NONE == cur_charge_phase 
 198   2              {
 199   3                  /*
 200   3                      如果当前没有在充电，并且指示灯处于充电指示模式，
 201   3                      切换回电池电量指示模式
 202   3      
 203   3                      测试时发现从充电到断开充电，led指示灯还在闪烁，需要加上这补丁
 204   3                  */
 205   3                  if (cur_led_mode == CUR_LED_MODE_CHARGING)
 206   3                  {
 207   4                      led_mode_alter(CUR_LED_MODE_BAT_INDICATOR);
 208   4                  }
 209   3      
 210   3                  // TODO：需要打开主灯光
 211   3                  // timer2_pwm_enable();
 212   3                  LIGHT_ON();
 213   3              }
 214   2      
 215   2              adc_update_bat_adc_val();
 216   2              led_handle();
 217   2              light_handle();
 218   2      
 219   2              // {
 220   2              //     static u8 cnt = 0;
 221   2              //     cnt++;
 222   2              //     if (cnt >= 200)
 223   2              //     {
 224   2              //         cnt = 0;
 225   2              //         // printf("bat_adc_val %u\n", bat_adc_val);
 226   2              //         printf("cur_light_pwm_duty_val %u\n", cur_light_pwm_duty_val); 
 227   2              //     }
 228   2              // }
 229   2      
 230   2              if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
 231   2              {
 232   3                  my_debug_led_2_off();
 233   3                  my_debug_led_3_off();
 234   3                  my_debug_led_4_off();
 235   3      
 236   3                  my_debug_led_1_on();
 237   3              }
 238   2              else if (CUR_CHARGE_PHASE_NORMAL_CHARGE == cur_charge_phase)
C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 5   

 239   2              {
 240   3                  my_debug_led_1_off();
 241   3                  my_debug_led_3_off();
 242   3                  my_debug_led_4_off();
 243   3      
 244   3                  my_debug_led_2_on();
 245   3              }
 246   2              else if (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE == cur_charge_phase)
 247   2              {
 248   3                  my_debug_led_1_off();
 249   3                  my_debug_led_2_off();
 250   3                  my_debug_led_4_off();
 251   3      
 252   3                  my_debug_led_3_on();
 253   3              }
 254   2              else if (CUR_CHARGE_PHASE_FULLY_CHARGE == cur_charge_phase)
 255   2              {
 256   3                  my_debug_led_1_off();
 257   3                  my_debug_led_2_off();
 258   3                  my_debug_led_3_off();
 259   3      
 260   3                  my_debug_led_4_on();
 261   3              }
 262   2      
 263   2              // my_debug_led_1_on();
 264   2              // my_debug_led_2_on();
 265   2              // my_debug_led_3_on();
 266   2              // my_debug_led_4_on();
 267   2      
 268   2      #if 0 // 缓慢调节驱动灯光的pwm占空比（还未调试完成）
              
                      {
                          // static u8 cnt =0;
              
                          // 暂定每100us调节一次
              
                          if (cur_light_pwm_duty_val > expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val--;
                          }
                          else if (cur_light_pwm_duty_val < expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val++;
                          }
              
                          SET_LIGHT_PWM_DUTY(cur_light_pwm_duty_val);
                          // timer2_set_pwm_duty(cur_light_pwm_duty_val);
                      }
              
              #endif // 缓慢调节驱动灯光的pwm占空比（还未调试完成）
 289   2      
 290   2      #endif
 291   2          }
 292   1      }
 293          
 294          /**
 295           * @}
 296           */
 297          
 298          /*************************** (C) COPYRIGHT 2022 HUGE-IC ***** END OF FILE *****/


C51 COMPILER V9.60.7.0   MAIN                                                              07/17/2025 14:41:40 PAGE 6   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    298    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =     30    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
