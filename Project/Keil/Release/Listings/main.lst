C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Release\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\main.lst) O
                    -BJECT(.\Release\Objects\main.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    main.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    01-05-2021
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2021 HUGE-IC</center></h2>
  12           *
  13           * 版权说明后续补上
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "include.h"
  20          #include <stdio.h>
  21          
  22          #include "user_config.h"
  23          
  24          volatile bit_flag flag1 = {0};
  25          volatile bit_flag flag2 = {0};
  26          
  27          volatile u8 cur_light_pwm_duty_val = 0;    // 当前灯光对应的占空比值
  28          volatile u8 expect_light_pwm_duty_val = 0; // 期望调节到的、灯光对应的占空比值
  29          
  30          volatile u16 bat_adc_val;
  31          volatile u16 charging_adc_val; // 检测到充电电压的ad值
  32          
  33          volatile u8 flag_is_light_adjust_time_come = 0; // 调节灯光的时间到来，目前为1s
  34          
  35          volatile u16 light_adjust_time_cnt = 0;
  36          
  37          //
  38          void led_pin_config(void)
  39          {
  40   1          P1_MD0 &= ~GPIO_P11_MODE_SEL(0x03);
  41   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x01);
  42   1          FOUT_S11 = GPIO_FOUT_AF_FUNC;
  43   1          P11 = 0; // 如果不给初始值，上电之后，指示灯会闪一下
  44   1      
  45   1          P1_MD0 &= ~GPIO_P12_MODE_SEL(0x03);
  46   1          P1_MD0 |= GPIO_P12_MODE_SEL(0x01);
  47   1          FOUT_S12 = GPIO_FOUT_AF_FUNC;
  48   1          P12 = 0;
  49   1      
  50   1          P1_MD0 &= ~GPIO_P13_MODE_SEL(0x03);
  51   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x01);
  52   1          FOUT_S13 = GPIO_FOUT_AF_FUNC;
  53   1          P13 = 0;
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 2   

  54   1      
  55   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03);
  56   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  57   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;
  58   1          P14 = 0;
  59   1      
  60   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03);
  61   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);
  62   1          FOUT_S15 = GPIO_FOUT_AF_FUNC;
  63   1          P15 = 0;
  64   1      }
  65          
  66          // // 绝对值函数
  67          // float my_fabs(float x) {
  68          //     return (x < 0) ? -x : x;
  69          // }
  70          
  71          // 泰勒展开近似 ln(x)，收敛范围：x > 0.1
  72          float my_ln(float x)
  73          {
  74   1          u8 i;
  75   1          float t = (x - 1) / (x + 1);
  76   1          float sum = 0.0f;
  77   1          float term = t;
  78   1      
  79   1          for (i = 0; i < 50; i++)
  80   1          {
  81   2              sum += term / (2 * i + 1);
  82   2              term *= t * t;
  83   2          }
  84   1      
  85   1          return 2 * sum;
  86   1      }
  87          
  88          // 泰勒展开近似 exp(x)
  89          float my_exp(float x)
  90          {
  91   1          u8 i;
  92   1          float sum = 1.0f;
  93   1          float term = 1.0f;
  94   1      
  95   1          for (i = 1; i < 20; i++)
  96   1          {
  97   2              term *= x / i;
  98   2              sum += term;
  99   2          }
 100   1      
 101   1          return sum;
 102   1      }
 103          
 104          // 幂函数：x^y = e^(y * ln(x))
 105          float my_pow(float base, float exponent)
 106          {
 107   1          if (base <= 0.0f)
 108   1          {
 109   2              return 0.0f; // 不支持负底数或0的负次幂
 110   2          }
 111   1          if (exponent == 0.0f)
 112   1              return 1.0f;
 113   1          if (base == 1.0f)
 114   1              return 1.0f;
 115   1      
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 3   

 116   1          return my_exp(exponent * my_ln(base));
 117   1      }
 118          
 119          // 返回值：占空比，单位：百分之一（例如 75 表示 75%）
 120          u8 calculate_duty(u32 voltage_mV)
 121          {
 122   1          // const float A = 538.0f;
 123   1          // const float n = 1.178f;
 124   1      
 125   1          const float A = 680.0F;
 126   1          const float n = 1.32F;
 127   1      
 128   1          // const float A = 376.26f;
 129   1          // const float A = 395.2f;
 130   1          // const float A = 348.32f;
 131   1          // const float A = 288.0F; 
 132   1           
 133   1          // const float n = 1.0f;
 134   1          float result;
 135   1      
 136   1          if (voltage_mV < 100)
 137   1              return 0; // 防止除零或过大输出
 138   1      
 139   1          voltage_mV /= 1000;
 140   1      
 141   1          result = A / my_pow(voltage_mV, n);
 142   1      
 143   1          if (result < 0.0f)
 144   1              result = 0.0f;
 145   1          if (result > 100.0f)
 146   1              result = 100.0f;
 147   1      
 148   1          return (u8)(result + 0.5f); // 四舍五入
 149   1      }
 150          
 151          /**
 152           * @brief  Main program.
 153           * @param  None
 154           * @retval None
 155           */
 156          void main(void)
 157          {
 158   1          // 看门狗默认打开, 复位时间2s
 159   1          WDT_KEY = WDT_KEY_VAL(0xDD); //  关闭看门狗 (如需配置看门狗请查看“WDT\WDT_Reset”示例)
 160   1      
 161   1          system_init();
 162   1      
 163   1          // 关闭HCK和HDA的调试功能
 164   1          WDT_KEY = 0x55;  // 解除写保护
 165   1          IO_MAP &= ~0x01; // 清除这个寄存器的值，实现关闭HCK和HDA引脚的调试功能（解除映射）
 166   1          WDT_KEY = 0xBB;  // 写一个无效的数据，触发写保护
 167   1      
 168   1          uart0_config();
 169   1          timer0_config();
 170   1          timer1_pwm_config(); // 控制充电的PWM
 171   1          timer1_pwm_disable();
 172   1          timer2_pwm_config(); // 控制灯光的pwm
 173   1          timer2_pwm_disable();
 174   1      
 175   1          // timer1_set_pwm_high_feq();
 176   1          // TODO: 7361不用加这个引脚配置:
 177   1          led_pin_config();
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 4   

 178   1      
 179   1          // 红外接收引脚：
 180   1          P2_MD0 &= ~(GPIO_P23_MODE_SEL(0x03)); // 输入模式
 181   1          P2_PU |= GPIO_P23_PULL_UP(0x01);      // 上拉
 182   1      
 183   1          adc_config();
 184   1      
 185   1          printf("sys reset\n");
 186   1      
 187   1      // LED_1_ON();
 188   1      // LED_2_ON();
 189   1      // LED_3_ON();
 190   1      // LED_4_ON();
 191   1      // LED_5_ON();
 192   1      
 193   1      // TODO:
 194   1      // 上电后，需要先点亮红色指示灯，再变为电池电量指示模式
 195   1      // LED_1_ON();
 196   1      // delay_ms(1000);
 197   1      
 198   1      // cur_led_mode = CUR_LED_MODE_INITIAL_DISCHARGE_GEAR;
 199   1      #if 0
                  cur_led_mode = CUR_LED_MODE_BAT_INDICATOR; // 电池电量指示模式
                  cur_initial_discharge_gear = 5;
                  cur_discharge_rate = 3;
              #endif
 204   1      
 205   1          timer1_set_pwm_high_feq();
 206   1          // TMR1_PWMH = ((TIMER1_HIGH_FEQ_PEROID_VAL * 9 / 100) >> 8) & 0xFF; //
 207   1          // TMR1_PWML = (TIMER1_HIGH_FEQ_PEROID_VAL * 9 / 100) & 0xFF;
 208   1      
 209   1          // TMR1_PWMH = ((TIMER1_HIGH_FEQ_PEROID_VAL * 75 / 100) >> 8) & 0xFF; //
 210   1          // TMR1_PWML = (TIMER1_HIGH_FEQ_PEROID_VAL * 75 / 100) & 0xFF;
 211   1      
 212   1          // {
 213   1          //     u8 tmp = 0;
 214   1          //     tmp = calculate_duty(5300);
 215   1      
 216   1          //     printf("tmp %bu\n", tmp);
 217   1      
 218   1          //     tmp = calculate_duty(11000);
 219   1          //     printf("tmp %bu\n", tmp);
 220   1      
 221   1          //     tmp = calculate_duty(32000);
 222   1          //     printf("tmp %bu\n", tmp);
 223   1          // }
 224   1      
 225   1          // {
 226   1          //     // u32 charging_voltage_mV = 0;
 227   1          //     // u16 pwm_duty = 0;
 228   1          //     // charging_voltage_mV = charging_adc_val * 2 * 11 * 1000 / 4096;
 229   1          //     // pwm_duty = calculate_duty(charging_voltage_mV);
 230   1          //     // pwm_duty = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty  / 100; // 最终的占空比值
 231   1          //     // TMR1_PWMH = (pwm_duty >> 8) & 0xFF;
 232   1          //     // TMR1_PWML = pwm_duty & 0xFF;
 233   1      
 234   1          //     u32 charging_voltage_mV = 0;
 235   1          //     u16 pwm_duty = 0;
 236   1          //     u8 i;
 237   1      
 238   1          //     for (i = 1; i <= 32; i++)
 239   1          //     {
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 5   

 240   1          //         pwm_duty = calculate_duty((u32)i * 1000);
 241   1          //         printf("pwm_duty :%bu %%\n", (u8)pwm_duty);
 242   1          //         pwm_duty = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty / 100; // 最终的占空比值
 243   1          //         printf("reg val %u \n", (u16)pwm_duty);
 244   1          //     }
 245   1          // }
 246   1      
 247   1          while (1)
 248   1          {
 249   2              // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
 250   2              // bat_adc_val = adc_getval(); // 采集电池电压对应的ad值
 251   2              adc_sel_pin(ADC_PIN_DETECT_CHARGE);
 252   2              charging_adc_val = adc_getval();
 253   2      
 254   2              {
 255   3                  u32 charging_voltage_mV = 0;
 256   3                  u16 pwm_duty = 0;
 257   3      
 258   3                  // charging_adc_val = 1117; // 测试用
 259   3                  charging_voltage_mV = (u32)charging_adc_val * 2 * 11 * 1000 / 4096;
 260   3                  // charging_voltage_mV = 6000; // 测试用
 261   3                  pwm_duty = calculate_duty(charging_voltage_mV);
 262   3                  pwm_duty = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty / 100; // 最终的占空比值
 263   3      
 264   3                  // printf("pwm_duty :%u\n", pwm_duty);
 265   3                  TMR1_PWMH = (pwm_duty >> 8) & 0xFF;
 266   3                  TMR1_PWML = pwm_duty & 0xFF;
 267   3              }
 268   2      
 269   2      #if 0
                      {
                          u32 tmp = 0;
              
                          // tmp = (u32)124286 - (u32)charging_adc_val * 7857 * 2 * 11 / 4096;
                          tmp = (u32)88101 - (u32)charging_adc_val * 2471 * 2 * 11 / 4096;
              
                          // tmp = (((u32)TMR1_PRH << 8) | (u32)TMR1_PRL) * (u32)tmp / 1000; // 最终的占空比值（用这个计
             -算，得出的值是0）
                          tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 100; // 最终的占空比值
              
                          /*
                              由于公式限制，可能充电电压大于15V就会导致占空比变为0，现在不让它到0%
                          */
                          if (0 == (u16)tmp)
                          // if (0 == tmp)
                          {
                              tmp = 0;
                          }
              
                          TMR1_PWMH = (tmp >> 8) & 0xFF;
                          TMR1_PWML = tmp & 0xFF;
                      }
              #endif
 292   2      
 293   2              // ir_handle();
 294   2              // charge_handle();
 295   2              // led_handle_update_percent_of_bat();
 296   2      
 297   2      #if 0 // 缓慢调节驱动灯光的pwm占空比
              
                      {
                          // static u8 cnt =0;
C51 COMPILER V9.60.7.0   MAIN                                                              07/10/2025 16:54:27 PAGE 6   

              
                          // 暂定每100us调节一次
              
                          if (cur_light_pwm_duty_val > expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val--;
                          }
                          else if (cur_light_pwm_duty_val < expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val++;
                          }
              
                          SET_LIGHT_PWM_DUTY(cur_light_pwm_duty_val);
                          // timer2_set_pwm_duty(cur_light_pwm_duty_val);
                      }
              
              #endif // 缓慢调节驱动灯光的pwm占空比
 318   2          }
 319   1      }
 320          
 321          /**
 322           * @}
 323           */
 324          
 325          /*************************** (C) COPYRIGHT 2022 HUGE-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1145    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =     11      60
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
