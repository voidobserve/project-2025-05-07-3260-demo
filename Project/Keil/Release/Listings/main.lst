C51 COMPILER V9.60.7.0   MAIN                                                              07/16/2025 16:01:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Release\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\main.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) INCDI
                    -R(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\main.lst) O
                    -BJECT(.\Release\Objects\main.obj)

line level    source

   1          /**
   2           ******************************************************************************
   3           * @file    main.c
   4           * @author  HUGE-IC Application Team
   5           * @version V1.0.0
   6           * @date    01-05-2021
   7           * @brief   Main program body
   8           ******************************************************************************
   9           * @attention
  10           *
  11           * <h2><center>&copy; COPYRIGHT 2021 HUGE-IC</center></h2>
  12           *
  13           * 版权说明后续补上
  14           *
  15           ******************************************************************************
  16           */
  17          
  18          /* Includes ------------------------------------------------------------------*/
  19          #include "include.h"
  20          #include <stdio.h>
  21          
  22          #include "user_config.h"
  23          
  24          volatile bit_flag flag1 = {0};
  25          volatile bit_flag flag2 = {0};
  26          
  27          // TODO：3260使用16位寄存器，7361使用8位寄存器，要进行适配修改 
  28          volatile u16 cur_light_pwm_duty_val = 0;    // 当前灯光对应的占空比值 
  29          volatile u16 expect_light_pwm_duty_val = 0; // 期望调节到的、灯光对应的占空比值 
  30          
  31          volatile u8 flag_is_light_adjust_time_come = 0; // 调节灯光的时间到来，目前为1s 
  32          
  33          // =================================================================
  34          // 充电控制相关变量                                                 //
  35          // =================================================================
  36          volatile u16 bat_adc_val;                                           // 电池电压检测脚采集到的ad值
  37          volatile u16 charging_adc_val;                                      // 充电电压检测脚采集的ad值
  38          volatile u16 current_adc_val;                                       // 充电电流检测脚采集的ad值
  39          volatile u8 flag_is_charging_adjust_time_come = 0;                  // 调节充电的时间到来
  40          volatile u8 cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE; // 控制充电的PWM状态
  41          volatile u8 cur_charge_phase = CUR_CHARGE_PHASE_NONE;               // 记录当前充电阶段
  42          
  43          volatile u32 light_adjust_time_cnt = 0;    // 调节灯光的时间计数，暂定为每1s加一
  44          volatile u8 light_ctl_phase_in_rate_1 = 1; // 在放电速率M1时，使用到的变量，在计算公式里面用作系数，每次唤
             -醒时需要初始化为1
  45          // volatile u8 flag_is_tim_turn_off_pwm = 0; // 标志位，在涓流充电期间，定时器是否关闭了PWM输出
  46          
  47          // =================================================================
  48          // 指示灯控制相关变量                                               //
  49          // =================================================================
  50          volatile u8 cur_initial_discharge_gear = 5; // 初始放电挡位（需要记忆）
  51          volatile u8 cur_discharge_rate = 1;         // 初始放电速率（需要记忆）
  52          volatile u8 cur_led_mode; // 当前的LED模式
C51 COMPILER V9.60.7.0   MAIN                                                              07/16/2025 16:01:08 PAGE 2   

  53          volatile u8 cur_led_gear;  // 当前led挡位
  54          volatile u8 last_led_gear; // 上次led挡位
  55          volatile u8 cur_led_gear_in_charging; // 充电指示，对应的挡位
  56          
  57          //
  58          void led_pin_config(void)
  59          {
  60   1          P1_MD0 &= ~GPIO_P11_MODE_SEL(0x03);
  61   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x01);
  62   1          FOUT_S11 = GPIO_FOUT_AF_FUNC;
  63   1          P11 = 0; // 如果不给初始值，上电之后，指示灯会闪一下
  64   1      
  65   1          P1_MD0 &= ~GPIO_P12_MODE_SEL(0x03);
  66   1          P1_MD0 |= GPIO_P12_MODE_SEL(0x01);
  67   1          FOUT_S12 = GPIO_FOUT_AF_FUNC;
  68   1          P12 = 0;
  69   1      
  70   1          P1_MD0 &= ~GPIO_P13_MODE_SEL(0x03);
  71   1          P1_MD0 |= GPIO_P13_MODE_SEL(0x01);
  72   1          FOUT_S13 = GPIO_FOUT_AF_FUNC;
  73   1          P13 = 0;
  74   1      
  75   1          P1_MD1 &= ~GPIO_P14_MODE_SEL(0x03);
  76   1          P1_MD1 |= GPIO_P14_MODE_SEL(0x01);
  77   1          FOUT_S14 = GPIO_FOUT_AF_FUNC;
  78   1          P14 = 0;
  79   1      
  80   1          P1_MD1 &= ~GPIO_P15_MODE_SEL(0x03);
  81   1          P1_MD1 |= GPIO_P15_MODE_SEL(0x01);
  82   1          FOUT_S15 = GPIO_FOUT_AF_FUNC;
  83   1          P15 = 0;
  84   1      }
  85          
  86          // 变量、参数，初始化
  87          void param_init(void)
  88          {
  89   1          light_ctl_phase_in_rate_1 = 1;
  90   1      }
  91          
  92          /**
  93           * @brief  Main program.
  94           * @param  None
  95           * @retval None
  96           */
  97          void main(void)
  98          {
  99   1          // 看门狗默认打开, 复位时间2s
 100   1          WDT_KEY = WDT_KEY_VAL(0xDD); //  关闭看门狗 (如需配置看门狗请查看“WDT\WDT_Reset”示例)
 101   1      
 102   1          system_init();
 103   1      
 104   1          // 关闭HCK和HDA的调试功能
 105   1          WDT_KEY = 0x55;  // 解除写保护
 106   1          IO_MAP &= ~0x01; // 清除这个寄存器的值，实现关闭HCK和HDA引脚的调试功能（解除映射）
 107   1          WDT_KEY = 0xBB;  // 写一个无效的数据，触发写保护
 108   1      
 109   1          uart0_config();
 110   1          my_debug_led_config();
 111   1      
 112   1          timer0_config();
 113   1          timer1_pwm_config(); // 控制充电的PWM
 114   1          timer1_pwm_disable();
C51 COMPILER V9.60.7.0   MAIN                                                              07/16/2025 16:01:08 PAGE 3   

 115   1          timer2_pwm_config(); // 控制灯光的pwm
 116   1          timer2_pwm_disable();
 117   1      
 118   1          // timer1_set_pwm_high_feq();
 119   1          // TODO: 7361不用加这个引脚配置:
 120   1          led_pin_config();
 121   1      
 122   1          // 红外接收引脚：
 123   1          P2_MD0 &= ~(GPIO_P23_MODE_SEL(0x03)); // 输入模式
 124   1          P2_PU |= GPIO_P23_PULL_UP(0x01);      // 上拉
 125   1      
 126   1          adc_config();
 127   1      
 128   1          printf("sys reset\n"); // 打印至少占用1012字节空间
 129   1      
 130   1          // TODO:
 131   1          // 上电后，需要先点亮红色指示灯，再变为电池电量指示模式
 132   1          // LED_1_ON();
 133   1          // delay_ms(1000);
 134   1      
 135   1          // cur_led_mode = CUR_LED_MODE_INITIAL_DISCHARGE_GEAR;
 136   1      
 137   1      #if 0
                  cur_led_mode = CUR_LED_MODE_BAT_INDICATOR; // 电池电量指示模式
                  cur_initial_discharge_gear = 5;
                  cur_discharge_rate = 3;
              #endif
 142   1      
 143   1          // timer1_set_pwm_high_feq();
 144   1      
 145   1          // {
 146   1          //     u16 pwm_reg = 0;                                     // 存放要写入到寄存器中的占空比值
 147   1          //     pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // 最终的占空比值
 148   1          //     TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 149   1          //     TMR1_PWML = pwm_reg & 0xFF;
 150   1          //     timer1_set_pwm_low_feq();
 151   1          //     cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
 152   1          //     // cur_charge_phase = CUR_CHARGE_PHASE_;
 153   1          // }
 154   1      
 155   1          while (1)
 156   1          {
 157   2      #if 1
 158   2              // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
 159   2              // bat_adc_val = adc_getval(); // 采集电池电压对应的ad值
 160   2              // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
 161   2              // adc_sel_pin_charge(CUR_ADC_REF_3_0_VOL);
 162   2              // charging_adc_val = adc_getval();
 163   2              // adc_sel_pin(ADC_PIN_DETECT_CURRENT);
 164   2              // current_adc_val = adc_getval(); // 采集流入电池的电流对应的ad值
 165   2      
 166   2              // printf("current_adc_val %u\n", current_adc_val);
 167   2      
 168   2              charge_handle();
 169   2      
 170   2              // ir_handle();
 171   2              // charge_handle();
 172   2              // led_handle_update_percent_of_bat();
 173   2      
 174   2              if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
 175   2              {
 176   3                  my_debug_led_2_off();
C51 COMPILER V9.60.7.0   MAIN                                                              07/16/2025 16:01:08 PAGE 4   

 177   3                  my_debug_led_3_off();
 178   3                  my_debug_led_4_off();
 179   3      
 180   3                  my_debug_led_1_on();
 181   3              }
 182   2              else if (CUR_CHARGE_PHASE_NORMAL_CHARGE == cur_charge_phase)
 183   2              {
 184   3                  my_debug_led_1_off();
 185   3                  my_debug_led_3_off();
 186   3                  my_debug_led_4_off();
 187   3      
 188   3                  my_debug_led_2_on();
 189   3              }
 190   2              else if (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE == cur_charge_phase)
 191   2              {
 192   3                  my_debug_led_1_off();
 193   3                  my_debug_led_2_off();
 194   3                  my_debug_led_4_off();
 195   3      
 196   3                  my_debug_led_3_on();
 197   3              }
 198   2              else if (CUR_CHARGE_PHASE_FULLY_CHARGE == cur_charge_phase)
 199   2              {
 200   3                  my_debug_led_1_off();
 201   3                  my_debug_led_2_off();
 202   3                  my_debug_led_3_off();
 203   3      
 204   3                  my_debug_led_4_on();
 205   3              }
 206   2      
 207   2              // my_debug_led_1_on();
 208   2              // my_debug_led_2_on();
 209   2              // my_debug_led_3_on();
 210   2              // my_debug_led_4_on();
 211   2      
 212   2      #if 0 // 缓慢调节驱动灯光的pwm占空比（还未调试完成）
              
                      {
                          // static u8 cnt =0;
              
                          // 暂定每100us调节一次
              
                          if (cur_light_pwm_duty_val > expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val--;
                          }
                          else if (cur_light_pwm_duty_val < expect_light_pwm_duty_val)
                          {
                              cur_light_pwm_duty_val++;
                          }
              
                          SET_LIGHT_PWM_DUTY(cur_light_pwm_duty_val);
                          // timer2_set_pwm_duty(cur_light_pwm_duty_val);
                      }
              
              #endif // 缓慢调节驱动灯光的pwm占空比（还未调试完成）
 233   2      
 234   2      #endif
 235   2          }
 236   1      }
 237          
 238          /**
C51 COMPILER V9.60.7.0   MAIN                                                              07/16/2025 16:01:08 PAGE 5   

 239           * @}
 240           */
 241          
 242          /*************************** (C) COPYRIGHT 2022 HUGE-IC ***** END OF FILE *****/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    231    ----
   CONSTANT SIZE    =     11    ----
   XDATA SIZE       =     27    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
