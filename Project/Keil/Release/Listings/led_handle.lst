C51 COMPILER V9.60.7.0   LED_HANDLE                                                        07/16/2025 16:44:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE LED_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\led_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\led_handle.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C)
                    - INCDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\led_h
                    -andle.lst) OBJECT(.\Release\Objects\led_handle.obj)

line level    source

   1          #include "led_handle.h"
   2          
   3          // TODO:需要初始化为5
   4          // volatile u8 bat_remaining_power_indication = 5; // 电池剩余电量指示挡位
   5          
   6          volatile u8 flag_is_update_led_mode_times_come = 0; // 标志位，LED模式的刷新时间到来
   7          
   8          #if 0  // 滑动平均
              /* 滑动平均 */
              static volatile u16 bat_adc_val_samples[BAT_ADC_VAL_SAMPLE_COUNT];
              static volatile u8 bat_adc_val_sample_index = 0;
              u16 get_filtered_bat_adc_val(u16 bat_adc_val)
              {
                  u8 i = 0;
                  u32 sum = 0;
                  bat_adc_val_samples[bat_adc_val_sample_index++] = bat_adc_val;
                  if (bat_adc_val_sample_index >= BAT_ADC_VAL_SAMPLE_COUNT)
                      bat_adc_val_sample_index = 0;
              
                  for (i = 0; i < BAT_ADC_VAL_SAMPLE_COUNT; i++)
                      sum += bat_adc_val_samples[i];
              
                  return sum / BAT_ADC_VAL_SAMPLE_COUNT;
              }
              #endif // 滑动平均
  26          
  27          /**
  28           * @brief 更新led指示灯相关的状态
  29           *          当 cur_led_mode 改变时，会调用此函数，
  30           *          并且要放在 led_handle_update_percent_of_bat() 函数前
  31           *
  32           */
  33          void led_stats_update(void)
  34          {
  35   1          LED_1_OFF();
  36   1          LED_2_OFF();
  37   1          LED_3_OFF();
  38   1          LED_4_OFF();
  39   1          LED_5_OFF();
  40   1          last_led_gear = 0; // 赋值为初始值
  41   1          cur_led_gear_in_charging = 0;
  42   1      }
  43          
  44          // 更新LED指示灯
  45          void led_handle_update_percent_of_bat(void)
  46          {
  47   1      
  48   1          // if (CUR_LED_MODE_OFF == cur_led_mode)
  49   1          // {
  50   1          //     refresh_led_mode_status(); // 关闭所有指示灯
  51   1          //     return;
  52   1          // }
  53   1      
C51 COMPILER V9.60.7.0   LED_HANDLE                                                        07/16/2025 16:44:58 PAGE 2   

  54   1          // 如果当前处于电池电量指示模式
  55   1          // 设备处于放电时，电量指示灯只显示电池电量降低的部分
  56   1          if (CUR_LED_MODE_BAT_INDICATOR == cur_led_mode)
  57   1          {
  58   2              /* 点亮指示灯1（放电模式，指示灯1始终点亮） */
  59   2              LED_1_ON();
  60   2      
  61   2              if (bat_adc_val > BAT_ADC_VAL_4) // 电池电量大于4格
  62   2              {
  63   3                  cur_led_gear = 5; // 亮5格
  64   3              }
  65   2              else if (bat_adc_val > BAT_ADC_VAL_3) // 电池电量大于3格
  66   2              {
  67   3                  cur_led_gear = 4; // 亮4格
  68   3              }
  69   2              else if (bat_adc_val > BAT_ADC_VAL_2) // 电池电量大于2格
  70   2              {
  71   3                  cur_led_gear = 3; // 亮3格
  72   3              }
  73   2              else if (bat_adc_val > BAT_ADC_VAL_1) // 电池电量大于1格
  74   2              {
  75   3                  cur_led_gear = 2; // 亮2格
  76   3              }
  77   2              else
  78   2              {
  79   3                  cur_led_gear = 1; // 亮1格
  80   3              }
  81   2      
  82   2              if (0 == last_led_gear)
  83   2              {
  84   3                  // 如果未初始化
  85   3                  last_led_gear = cur_led_gear;
  86   3              }
  87   2              else
  88   2              {
  89   3                  // 如果 last_led_gear 不为0，则说明已经初始化过了
  90   3      
  91   3                  if (cur_led_gear > last_led_gear)
  92   3                  {
  93   4                      // 如果当前要显示的指示灯 大于 上次显示的指示灯（样机在电池电
             -上升的情况下，不会更新显示）
  94   4                      cur_led_gear = last_led_gear;
  95   4                  }
  96   3              }
  97   2      
  98   2              if (cur_led_gear >= 5)
  99   2              {
 100   3                  LED_5_ON();
 101   3              }
 102   2              else
 103   2              {
 104   3                  LED_5_OFF();
 105   3              }
 106   2      
 107   2              if (cur_led_gear >= 4)
 108   2              {
 109   3                  LED_4_ON();
 110   3              }
 111   2              else
 112   2              {
 113   3                  LED_4_OFF();
 114   3              }
C51 COMPILER V9.60.7.0   LED_HANDLE                                                        07/16/2025 16:44:58 PAGE 3   

 115   2      
 116   2              if (cur_led_gear >= 3)
 117   2              {
 118   3                  LED_3_ON();
 119   3              }
 120   2              else
 121   2              {
 122   3                  LED_3_OFF();
 123   3              }
 124   2      
 125   2              if (cur_led_gear >= 2)
 126   2              {
 127   3                  LED_2_ON();
 128   3              }
 129   2              else
 130   2              {
 131   3                  LED_2_OFF();
 132   3              }
 133   2      
 134   2          } // if (CUR_LED_MODE_BAT_INDICATOR == cur_led_mode)
 135   1          else if (CUR_LED_MODE_DISCHARGE_RATE == cur_led_mode) // 放电速率指示模式，M1、M2、M3
 136   1          {
 137   2              switch (cur_discharge_rate)
 138   2              {
 139   3              case 1:
 140   3                  LED_1_ON();
 141   3                  break;
 142   3              case 2:
 143   3                  LED_2_ON();
 144   3                  break;
 145   3              case 3:
 146   3                  LED_3_ON();
 147   3                  break;
 148   3              }
 149   2          }
 150   1          else if (CUR_LED_MODE_CHARGING == cur_led_mode) // 充电指示模式
 151   1          {
 152   2              // 在充电指示模式中，如果电池电量降低，不更新显示
 153   2              // TODO：样机是在电池电压超过3.55V并且进入涓流充电，绿色指示灯才一直
             -亮(第5格指示灯)
 154   2      
 155   2              /* 点亮指示灯1（指示灯1始终点亮） */
 156   2              LED_1_ON();
 157   2      
 158   2              if (bat_adc_val > BAT_ADC_VAL_5) // 电池电量大于5格
 159   2              {
 160   3                  cur_led_gear = 6; // 亮5格，并且所有指示灯常亮
 161   3              }
 162   2              else if (bat_adc_val > BAT_ADC_VAL_4) // 电池电量大于4格
 163   2              {
 164   3                  cur_led_gear = 5; // 亮5格，让第5格闪烁
 165   3              }
 166   2              else if (bat_adc_val > BAT_ADC_VAL_3) // 电池电量大于3格
 167   2              {
 168   3                  cur_led_gear = 4; // 亮4格，让第4格闪烁
 169   3              }
 170   2              else if (bat_adc_val > BAT_ADC_VAL_2) // 电池电量大于2格
 171   2              {
 172   3                  cur_led_gear = 3; // 亮3格，让第3格闪烁
 173   3              }
 174   2              else if (bat_adc_val > BAT_ADC_VAL_1) // 电池电量大于1格
 175   2              {
C51 COMPILER V9.60.7.0   LED_HANDLE                                                        07/16/2025 16:44:58 PAGE 4   

 176   3                  cur_led_gear = 2; // 亮2格，让第2格闪烁
 177   3              }
 178   2              else
 179   2              {
 180   3                  cur_led_gear = 1; // 亮1格，让第2格闪烁
 181   3              }
 182   2      
 183   2              if (0 == last_led_gear)
 184   2              {
 185   3                  last_led_gear = cur_led_gear;
 186   3              }
 187   2              else
 188   2              {
 189   3                  if (cur_led_gear < last_led_gear)
 190   3                  {
 191   4                      // 在充电指示模式中，如果电池电量降低，不更新显示
 192   4                      cur_led_gear = last_led_gear;
 193   4                  }
 194   3              }
 195   2      
 196   2              cur_led_gear_in_charging = cur_led_gear; // 更新数值，给定时器中断使用
 197   2              delay_ms(1);
 198   2      
 199   2              if (cur_led_gear >= 3)
 200   2              {
 201   3                  LED_2_ON();
 202   3              }
 203   2      
 204   2              if (cur_led_gear >= 4)
 205   2              {
 206   3                  LED_3_ON();
 207   3              }
 208   2      
 209   2              if (cur_led_gear >= 5)
 210   2              {
 211   3                  LED_4_ON();
 212   3              }
 213   2      
 214   2              if (cur_led_gear >= 6)
 215   2              {
 216   3                  LED_5_ON();
 217   3              }
 218   2          }
 219   1      
 220   1          if (flag_is_update_led_mode_times_come) // 时间到来，回到电池电量指示模式
 221   1          {
 222   2              flag_is_update_led_mode_times_come = 0;
 223   2      
 224   2              if (cur_light_pwm_duty_val) // 如果灯光还是亮着的
 225   2              {
 226   3                  cur_led_mode = CUR_LED_MODE_BAT_INDICATOR; // 恢复到电池电量指示模式
 227   3              }
 228   2              else // 如果灯光已经熄灭
 229   2              {
 230   3                  cur_led_mode = CUR_LED_MODE_OFF; // 恢复到关机模式
 231   3              }
 232   2      
 233   2              flag_is_in_setting_mode = 0; // 退出设置模式
 234   2          }
 235   1      
 236   1          if (CUR_LED_MODE_OFF == cur_led_mode)
 237   1          {
C51 COMPILER V9.60.7.0   LED_HANDLE                                                        07/16/2025 16:44:58 PAGE 5   

 238   2              LED_1_OFF();
 239   2              LED_2_OFF();
 240   2              LED_3_OFF();
 241   2              LED_4_OFF();
 242   2              LED_5_OFF();
 243   2          }
 244   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    638    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
