C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/09/2025 10:39:37 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CHARGE_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\charge_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\charge_handle.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\ch
                    -arge_handle.lst) OBJECT(.\Release\Objects\charge_handle.obj)

line level    source

   1          #include "charge_handle.h"
   2          
   3          volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE;
   4          
   5          // å……ç”µæ§åˆ¶
   6          void charge_handle(void)
   7          {
   8   1          // static volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE; // æµ‹è¯•ç”¨
   9   1      
  10   1          /*
  11   1              æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½å……ç”µï¼Œç”¨äºæ§åˆ¶å……æ»¡ç”µåï¼Œç­‰åˆ°å……ç”µç”µå‹å°äºä¸€å®šå€¼ä¹‹å
             -ï¼Œå†ä½¿èƒ½å……ç”µ
  12   1              0 -- ä¸ä½¿èƒ½å……ç”µ
  13   1              1 -- ä½¿èƒ½å……ç”µ
  14   1          */
  15   1          static volatile u8 flag_is_enable_charging = 0;
  16   1      
  17   1          // volatile u16 charging_adc_val;
  18   1          // volatile u16 bat_adc_val;
  19   1          u32 tmp;
  20   1      
  21   1          // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  22   1          // charging_adc_val = adc_getval(); // é‡‡é›†å……ç”µè¾“å…¥å¯¹åº”çš„adå€¼
  23   1          // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
  24   1          // bat_adc_val = adc_getval(); // é‡‡é›†ç”µæ± ç”µå‹å¯¹åº”çš„adå€¼
  25   1      
  26   1      #if 0
                  {
                      static u16 cnt = 0;
                      cnt++;
                      if (cnt >= 100)
                      {
                          cnt = 0;
                          printf("cur_charging_adc_val : %u\n", charging_adc_val);
                          // printf("cur_bat_adc_val : %u\n", bat_adc_val);
              
                          // printf("detect vol of charge: %u mV\n", (u16)((u32)charging_adc_val * 2 * 11000 / 4096));
                          // printf("detect vol of bat: %u mV\n", (u16)((u32)bat_adc_val * 2 * 2 * 1000 / 4096));
                      }
                  }
              #endif
  41   1      
  42   1      #if 1
  43   1          // å¦‚æœå½“å‰æœªåœ¨å……ç”µ
  44   1          if (CUR_CHARGE_STATUS_NONE == cur_charge_status)
  45   1          {
  46   2              /* å¦‚æœç”µæ± ä¹‹å‰å……æ»¡ç”µï¼Œè¦ç­‰åˆ°å……ç”µç”µå‹å°äºä¸€å®šå€¼ï¼Œå†ä½¿èƒ½å……ç”µ */
  47   2              if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END)
  48   2              {
  49   3                  flag_is_enable_charging = 1; // ä½¿èƒ½å……ç”µ
  50   3              }
  51   2      
  52   2              if (charging_adc_val >= ADC_VAL_ENABLE_IN_CHARGE_END)
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/09/2025 10:39:37 PAGE 2   

  53   2              {
  54   3                  // å¦‚æœåœ¨æœªå……ç”µæ—¶ï¼Œæ£€æµ‹åˆ°å……ç”µè¾“å…¥ç”µå‹è€Œä½¿èƒ½å……ç”µ
  55   3      
  56   3                  if (flag_is_enable_charging) // å¦‚æœä½¿èƒ½äº†å……ç”µ
  57   3                  {
  58   4                      flag_is_enable_charging = 0; // æ ‡å¿—ä½æ¸…é›¶
  59   4                      cur_charge_status = CUR_CHARGE_STATUS_IN_CHARGING;
  60   4                      // printf("in charging\n");
  61   4                  }
  62   3              }
  63   2          }
  64   1          else // å¦‚æœå½“å‰æ­£åœ¨å……ç”µ
  65   1          {
  66   2              static u8 cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  67   2      
  68   2              if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END || /* å¦‚æœå……ç”µç”µå‹è¿‡å° */
  69   2                  // charging_adc_val >= 2420 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 13V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™· */
  70   2                  // charging_adc_val >= 2973 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 15V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™· */
  71   2                  bat_adc_val >= ADC_VAL_BAT_IS_FULL) /* å¦‚æœç”µæ± å·²ç»æ»¡ç”µ */
  72   2              {
  73   3                  // å……ç”µè¾“å…¥çš„ç”µå‹å°äºä¸€å®šå€¼ï¼Œæ–­å¼€å……ç”µ
  74   3                  // ç”µæ±  å·²ç»æ»¡ç”µï¼Œ æ–­å¼€å……ç”µ
  75   3                  // timer0_pwm_disable();
  76   3                  PWM_CTL_FOR_CHARGING_DISABLE();
  77   3                  cur_charge_status = CUR_CHARGE_STATUS_NONE;
  78   3                  cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  79   3      
  80   3                  printf("disable charge\n");
  81   3                  return;
  82   3              }
  83   2      
  84   2              // è¿›è¡Œæ¶“æµå……ç”µï¼š
  85   2              if (bat_adc_val <= ADC_VAL_BAT_IS_LOW ||       /* å¦‚æœç”µæ± ç”µå‹å°äºä¸€å®šå€¼ */
  86   2                  bat_adc_val >= ADC_VAL_BAT_IS_NEAR_FULL || /* å¦‚æœç”µæ± ç”µå‹å¤§äºä¸€å®šå€¼ */
  87   2                  charging_adc_val < 930)                    /* å……ç”µç”µå‹å°äº5V */
  88   2              {
  89   3                  if (CUR_CHARGING_PWM_STATUS_LOW_FEQ != cur_charging_pwm_status)
  90   3                  {
  91   4                      // timer0_pwm_set_low_feq(); // å‡½æ•°å†…éƒ¨è®¾å®šäº†å›ºå®šé¢‘ç‡å’Œå›ºå®šå ç©ºæ¯”
  92   4                      // PWM_CTL_FOR_CHARGING_SET_LOW_FEQ();
  93   4                      tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * 1 / 100; // 1% å ç©ºæ¯”
  94   4                      TMR1_PWMH = (tmp >> 8) & 0xFF;
  95   4                      TMR1_PWML = tmp & 0xFF;
  96   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
  97   4      
  98   4                      printf("low feq charge\n");
  99   4                  }
 100   3              }
 101   2              else // å¦‚æœç”µæ± ç”µå‹ä¸æ˜¯åœ¨æ¶“æµå……ç”µçš„èŒƒå›´
 102   2              {
 103   3                  // u32 tmp;
 104   3                  // å¦‚æœç”µæ± ç”µå‹ä¸åœ¨æ¶“æµå……ç”µçš„åŒºé—´ï¼Œåˆ™æ­£å¸¸å……ç”µ
 105   3                  // æ³¨æ„è¿™é‡Œä¸èƒ½éšæ„æ”¹å˜ PWMå ç©ºæ¯”ï¼Œæœ€å¥½è®¾ç½®PWMå ç©ºæ¯”ä¸º0
 106   3                  if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ != cur_charging_pwm_status)
 107   3                  {
 108   4                      // timer0_pwm_set_high_feq();
 109   4                      PWM_CTL_FOR_CHARGING_SET_HIGH_FEQ();
 110   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_HIGH_FRQ;
 111   4                  }
 112   3      
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/09/2025 10:39:37 PAGE 3   

 113   3                  // æ ¹æ®å……ç”µç”µå‹è°ƒæ•´pwmå ç©ºæ¯”
 114   3      
 115   3                  // æ­£å¸¸å……ç”µæ—¶ï¼Œæ‰è°ƒèŠ‚æ§åˆ¶å……ç”µçš„PWMå ç©ºæ¯”
 116   3                  if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ == cur_charging_pwm_status)
 117   3                  {
 118   4                      /*
 119   4                             æµ‹å¾—æ ·æœºå……ç”µæ§åˆ¶çš„åŠŸèƒ½ï¼š
 120   4                             5Vè¾“å…¥ï¼Œpwm 105Khzï¼Œ90%ï¼Œï¼ˆå¯èƒ½è¦ä½¿ç”¨ 105Khzï¼Œ85%ï¼‰ï¼›12Vè¾“å…¥ï¼Œpwm 
             -105Khzï¼Œ30%
 121   4                             ç”¨ï¼ˆ5Vï¼Œ85%ï¼‰å’Œï¼ˆ12Vï¼Œ30%ï¼‰è¿™ä¸¤ä¸ªç‚¹æ¥è®¡ç®—ï¼Œ
 122   4                             å·²çŸ¥ä¸¤ç‚¹åæ ‡(5,85),(12,30)ï¼Œæ±‚å¯¹åº”çš„æ–¹ç¨‹ï¼Œ
 123   4                             å¯¹åº”ç›´çº¿çš„æ–¹ç¨‹ï¼š y  =  -7.857x  + 124.286
 124   4                             y å¯¹åº”å ç©ºæ¯”ï¼Œå•ä½ï¼š%ï¼›x å¯¹åº”å……ç”µè¾“å…¥ç”µå‹ï¼Œå•ä½ï¼šV
 125   4                             åœ¨å…¬å¼ä¸Šå»æ‰å°æ•°ç‚¹ï¼š
 126   4                             1000y = -7857x + 124286
 127   4      
 128   4                             å•ç‰‡æœºadcä½¿ç”¨å†…éƒ¨2.0Vå‚è€ƒç”µå‹ï¼Œ
 129   4                             å°†å…¬å¼è½¬æ¢æˆ å ç©ºæ¯” å’Œ adå€¼ çš„å…³ç³»:
 130   4                             å¤–éƒ¨å……ç”µè¾“å…¥çš„ç”µå‹ 1/11 åˆ†å‹åï¼Œåˆ°å•ç‰‡æœºæ£€æµ‹è„š
 131   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ / 11 / å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 4096 == å•ç‰‡æœºé‡‡é›†åˆ°çš„a
             -då€¼
 132   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ / 4096 * å•ç‰‡æœºadcå‚è€ƒç”µå‹ 
             -* 11
 133   4                             æ¢ç®—æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
 134   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ * å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 11 / 
             -4096
 135   4                             x = adc_val * 2 * 11 / 4096
 136   4      
 137   4                             å¾—åˆ°çš„å…¬å¼ï¼š
 138   4                             1000y = 124286 - 7857 (adc_val * 2 * 11 / 4096)
 139   4                             1000y = 124286 - adc_val * 7857 * 2 * 11 / 4096
 140   4                             è¿™ä¸ªå…¬å¼è¿ç®—ä¸ä¼šè¶…å‡º 2^32 èŒƒå›´
 141   4                         */
 142   4                      // tmp = (u32)124286 - (u32)charging_adc_val * 7857 * 2 * 11 / 4096;
 143   4                      tmp = (u32)88101 - (u32)charging_adc_val * 2471 * 2 * 11 / 4096;
 144   4                      // å¾—åˆ°çš„ tmp æ˜¯1000å€çš„å ç©ºæ¯”å€¼ï¼Œéœ€è¦é™¤ä»¥1000ï¼Œ å†ä¹˜ä»¥ å®šæ—¶å™¨é‡è½½
             -å€¼/100,å¾—åˆ°å®šæ—¶å™¨å¯¹åº”çš„å ç©ºæ¯”å€¼
 145   4                      // // T1DATA = (u32)T1LOAD * (u32)tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 146   4                      // {
 147   4                      //     static u16 cnt = 0;
 148   4                      //     cnt++;
 149   4                      //     if (cnt >= 100)
 150   4                      //     {
 151   4                      //         cnt = 0;
 152   4                      //         printf("cur pwm percent : %lu %%\n", (u32)tmp / 1000);
 153   4                      //         // printf("cal val  : %lu \n", (u32)charging_adc_val * 7857 * 2 * 11 / 4096);
 154   4                      //     }
 155   4                      // }
 156   4      
 157   4                      // tmp = (((u32)TMR1_PRH << 8) | (u32)TMR1_PRL) * (u32)tmp / 1000; // æœ€ç»ˆçš„å ç©ºæ¯”å€
             -¼ï¼ˆç”¨è¿™ä¸ªè®¡ç®—ï¼Œå¾—å‡ºçš„å€¼æ˜¯0ï¼‰
 158   4                      tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 159   4      
 160   4                      /*
 161   4                          ç”±äºå…¬å¼é™åˆ¶ï¼Œå¯èƒ½å……ç”µç”µå‹å¤§äº15Vå°±ä¼šå¯¼è‡´å ç©ºæ¯”å˜ä¸º0ï¼Œç°åœ¨ä
             -¸è®©å®ƒåˆ°0%
 162   4                      */
 163   4                      if (0 == (u16)tmp)
 164   4                      // if (0 == tmp)
 165   4                      {
 166   5                          tmp = 0;
 167   5                      }
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/09/2025 10:39:37 PAGE 4   

 168   4      
 169   4      #if 0
                              {
                                  static u16 cnt = 0;
                                  cnt++;
                                  if (cnt >= 100)
                                  {
                                      cnt = 0;
                                      // printf("reg val : %u \n", (u16)tmp);
                                      // printf("reg val : %u \n", (u16)(((u32)TMR1_PRH << 8) | (u32)TMR1_PRL));
                                      // printf("reg val : %u \n", (u16)((u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 
             -100));
                                  }
                              }
              #endif
 182   4      
 183   4                      TMR1_PWMH = (tmp >> 8) & 0xFF;
 184   4                      TMR1_PWML = tmp & 0xFF;
 185   4                  }
 186   3              }
 187   2          }
 188   1      #endif
 189   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    407    ----
   CONSTANT SIZE    =     32    ----
   XDATA SIZE       =      3       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
