C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/11/2025 17:45:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CHARGE_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\charge_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\charge_handle.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\ch
                    -arge_handle.lst) OBJECT(.\Release\Objects\charge_handle.obj)

line level    source

   1          #include "charge_handle.h"
   2          
   3          volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE;
   4          
   5          #if 0
              // å……ç”µæ§åˆ¶
              void charge_handle(void)
              {
                  // static volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE; // æµ‹è¯•ç”¨
              
                  /*
                      æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½å……ç”µï¼Œç”¨äºæ§åˆ¶å……æ»¡ç”µåï¼Œç­‰åˆ°å……ç”µç”µå‹å°äºä¸€å®šå€¼ä¹‹å
             -ï¼Œå†ä½¿èƒ½å……ç”µ
                      0 -- ä¸ä½¿èƒ½å……ç”µ
                      1 -- ä½¿èƒ½å……ç”µ
                  */
                  static volatile u8 flag_is_enable_charging = 0;
              
                  // volatile u16 charging_adc_val;
                  // volatile u16 bat_adc_val;
                  u32 tmp;
              
                  // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
                  // charging_adc_val = adc_getval(); // é‡‡é›†å……ç”µè¾“å…¥å¯¹åº”çš„adå€¼
                  // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
                  // bat_adc_val = adc_getval(); // é‡‡é›†ç”µæ± ç”µå‹å¯¹åº”çš„adå€¼
              
              #if 0
                  {
                      static u16 cnt = 0;
                      cnt++;
                      if (cnt >= 100)
                      {
                          cnt = 0;
                          printf("cur_charging_adc_val : %u\n", charging_adc_val);
                          // printf("cur_bat_adc_val : %u\n", bat_adc_val);
              
                          // printf("detect vol of charge: %u mV\n", (u16)((u32)charging_adc_val * 2 * 11000 / 4096));
                          // printf("detect vol of bat: %u mV\n", (u16)((u32)bat_adc_val * 2 * 2 * 1000 / 4096));
                      }
                  }
              #endif
              
              #if 1
                  // å¦‚æœå½“å‰æœªåœ¨å……ç”µ
                  if (CUR_CHARGE_STATUS_NONE == cur_charge_status)
                  {
                      /* å¦‚æœç”µæ± ä¹‹å‰å……æ»¡ç”µï¼Œè¦ç­‰åˆ°å……ç”µç”µå‹å°äºä¸€å®šå€¼ï¼Œå†ä½¿èƒ½å……ç”µ */
                      if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END)
                      {
                          flag_is_enable_charging = 1; // ä½¿èƒ½å……ç”µ
                      }
              
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/11/2025 17:45:29 PAGE 2   

                      if (charging_adc_val >= ADC_VAL_ENABLE_IN_CHARGE_END)
                      {
                          // å¦‚æœåœ¨æœªå……ç”µæ—¶ï¼Œæ£€æµ‹åˆ°å……ç”µè¾“å…¥ç”µå‹è€Œä½¿èƒ½å……ç”µ
              
                          if (flag_is_enable_charging) // å¦‚æœä½¿èƒ½äº†å……ç”µ
                          {
                              flag_is_enable_charging = 0; // æ ‡å¿—ä½æ¸…é›¶
                              cur_charge_status = CUR_CHARGE_STATUS_IN_CHARGING;
                              // printf("in charging\n");
                          }
                      }
                  }
                  else // å¦‚æœå½“å‰æ­£åœ¨å……ç”µ
                  {
                      static u8 cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
              
                      if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END || /* å¦‚æœå……ç”µç”µå‹è¿‡å° */
                          // charging_adc_val >= 2420 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 13V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™· */
                          // charging_adc_val >= 2973 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 15V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™· */
                          bat_adc_val >= ADC_VAL_BAT_IS_FULL) /* å¦‚æœç”µæ± å·²ç»æ»¡ç”µ */
                      {
                          // å……ç”µè¾“å…¥çš„ç”µå‹å°äºä¸€å®šå€¼ï¼Œæ–­å¼€å……ç”µ
                          // ç”µæ±  å·²ç»æ»¡ç”µï¼Œ æ–­å¼€å……ç”µ
                          // timer0_pwm_disable();
                          PWM_CTL_FOR_CHARGING_DISABLE();
                          cur_charge_status = CUR_CHARGE_STATUS_NONE;
                          cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
              
                          printf("disable charge\n");
                          return;
                      }
              
                      // è¿›è¡Œæ¶“æµå……ç”µï¼š
                      if (bat_adc_val <= ADC_VAL_BAT_IS_LOW ||       /* å¦‚æœç”µæ± ç”µå‹å°äºä¸€å®šå€¼ */
                          bat_adc_val >= ADC_VAL_BAT_IS_NEAR_FULL || /* å¦‚æœç”µæ± ç”µå‹å¤§äºä¸€å®šå€¼ */
                          charging_adc_val < 930)                    /* å……ç”µç”µå‹å°äº5V */
                      {
                          if (CUR_CHARGING_PWM_STATUS_LOW_FEQ != cur_charging_pwm_status)
                          {
                              // timer0_pwm_set_low_feq(); // å‡½æ•°å†…éƒ¨è®¾å®šäº†å›ºå®šé¢‘ç‡å’Œå›ºå®šå ç©ºæ¯”
                              // PWM_CTL_FOR_CHARGING_SET_LOW_FEQ();
                              tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * 1 / 100; // 1% å ç©ºæ¯”
                              TMR1_PWMH = (tmp >> 8) & 0xFF;
                              TMR1_PWML = tmp & 0xFF;
                              cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
              
                              printf("low feq charge\n");
                          }
                      }
                      else // å¦‚æœç”µæ± ç”µå‹ä¸æ˜¯åœ¨æ¶“æµå……ç”µçš„èŒƒå›´
                      {
                          // u32 tmp;
                          // å¦‚æœç”µæ± ç”µå‹ä¸åœ¨æ¶“æµå……ç”µçš„åŒºé—´ï¼Œåˆ™æ­£å¸¸å……ç”µ
                          // æ³¨æ„è¿™é‡Œä¸èƒ½éšæ„æ”¹å˜ PWMå ç©ºæ¯”ï¼Œæœ€å¥½è®¾ç½®PWMå ç©ºæ¯”ä¸º0
                          if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ != cur_charging_pwm_status)
                          {
                              // timer0_pwm_set_high_feq();
                              PWM_CTL_FOR_CHARGING_SET_HIGH_FEQ();
                              cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_HIGH_FRQ;
                          }
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/11/2025 17:45:29 PAGE 3   

              
                          // æ ¹æ®å……ç”µç”µå‹è°ƒæ•´pwmå ç©ºæ¯”
              
                          // æ­£å¸¸å……ç”µæ—¶ï¼Œæ‰è°ƒèŠ‚æ§åˆ¶å……ç”µçš„PWMå ç©ºæ¯”
                          if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ == cur_charging_pwm_status)
                          {
                              /*
                                     æµ‹å¾—æ ·æœºå……ç”µæ§åˆ¶çš„åŠŸèƒ½ï¼š
                                     5Vè¾“å…¥ï¼Œpwm 105Khzï¼Œ90%ï¼Œï¼ˆå¯èƒ½è¦ä½¿ç”¨ 105Khzï¼Œ85%ï¼‰ï¼›12Vè¾“å…¥ï¼Œpwm 
             -105Khzï¼Œ30%
                                     ç”¨ï¼ˆ5Vï¼Œ85%ï¼‰å’Œï¼ˆ12Vï¼Œ30%ï¼‰è¿™ä¸¤ä¸ªç‚¹æ¥è®¡ç®—ï¼Œ
                                     å·²çŸ¥ä¸¤ç‚¹åæ ‡(5,85),(12,30)ï¼Œæ±‚å¯¹åº”çš„æ–¹ç¨‹ï¼Œ
                                     å¯¹åº”ç›´çº¿çš„æ–¹ç¨‹ï¼š y  =  -7.857x  + 124.286
                                     y å¯¹åº”å ç©ºæ¯”ï¼Œå•ä½ï¼š%ï¼›x å¯¹åº”å……ç”µè¾“å…¥ç”µå‹ï¼Œå•ä½ï¼šV
                                     åœ¨å…¬å¼ä¸Šå»æ‰å°æ•°ç‚¹ï¼š
                                     1000y = -7857x + 124286
              
                                     å•ç‰‡æœºadcä½¿ç”¨å†…éƒ¨2.0Vå‚è€ƒç”µå‹ï¼Œ
                                     å°†å…¬å¼è½¬æ¢æˆ å ç©ºæ¯” å’Œ adå€¼ çš„å…³ç³»:
                                     å¤–éƒ¨å……ç”µè¾“å…¥çš„ç”µå‹ 1/11 åˆ†å‹åï¼Œåˆ°å•ç‰‡æœºæ£€æµ‹è„š
                                     å¤–éƒ¨è¾“å…¥ç”µå‹ / 11 / å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 4096 == å•ç‰‡æœºé‡‡é›†åˆ°çš„a
             -då€¼
                                     å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ / 4096 * å•ç‰‡æœºadcå‚è€ƒç”µå‹ 
             -* 11
                                     æ¢ç®—æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
                                     å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ * å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 11 / 
             -4096
                                     x = adc_val * 2 * 11 / 4096
              
                                     å¾—åˆ°çš„å…¬å¼ï¼š
                                     1000y = 124286 - 7857 (adc_val * 2 * 11 / 4096)
                                     1000y = 124286 - adc_val * 7857 * 2 * 11 / 4096
                                     è¿™ä¸ªå…¬å¼è¿ç®—ä¸ä¼šè¶…å‡º 2^32 èŒƒå›´
                                 */
                              // tmp = (u32)124286 - (u32)charging_adc_val * 7857 * 2 * 11 / 4096;
                              tmp = (u32)88101 - (u32)charging_adc_val * 2471 * 2 * 11 / 4096;
                              // å¾—åˆ°çš„ tmp æ˜¯1000å€çš„å ç©ºæ¯”å€¼ï¼Œéœ€è¦é™¤ä»¥1000ï¼Œ å†ä¹˜ä»¥ å®šæ—¶å™¨é‡è½½
             -å€¼/100,å¾—åˆ°å®šæ—¶å™¨å¯¹åº”çš„å ç©ºæ¯”å€¼
                              // // T1DATA = (u32)T1LOAD * (u32)tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
                              // {
                              //     static u16 cnt = 0;
                              //     cnt++;
                              //     if (cnt >= 100)
                              //     {
                              //         cnt = 0;
                              //         printf("cur pwm percent : %lu %%\n", (u32)tmp / 1000);
                              //         // printf("cal val  : %lu \n", (u32)charging_adc_val * 7857 * 2 * 11 / 4096);
                              //     }
                              // }
              
                              // tmp = (((u32)TMR1_PRH << 8) | (u32)TMR1_PRL) * (u32)tmp / 1000; // æœ€ç»ˆçš„å ç©ºæ¯”å€
             -¼ï¼ˆç”¨è¿™ä¸ªè®¡ç®—ï¼Œå¾—å‡ºçš„å€¼æ˜¯0ï¼‰
                              tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
              
                              /*
                                  ç”±äºå…¬å¼é™åˆ¶ï¼Œå¯èƒ½å……ç”µç”µå‹å¤§äº15Vå°±ä¼šå¯¼è‡´å ç©ºæ¯”å˜ä¸º0ï¼Œç°åœ¨ä
             -¸è®©å®ƒåˆ°0%
                              */
                              if (0 == (u16)tmp)
                              // if (0 == tmp)
                              {
                                  tmp = 0;
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/11/2025 17:45:29 PAGE 4   

                              }
              
              #if 0
                              {
                                  static u16 cnt = 0;
                                  cnt++;
                                  if (cnt >= 100)
                                  {
                                      cnt = 0;
                                      // printf("reg val : %u \n", (u16)tmp);
                                      // printf("reg val : %u \n", (u16)(((u32)TMR1_PRH << 8) | (u32)TMR1_PRL));
                                      // printf("reg val : %u \n", (u16)((u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 
             -100));
                                  }
                              }
              #endif
              
                              TMR1_PWMH = (tmp >> 8) & 0xFF;
                              TMR1_PWML = tmp & 0xFF;
                          }
                      }
                  }
              #endif
              }
              
              #endif
 193          
 194          
 195          
 196          
 197          
 198          
 199          // å……ç”µæ§åˆ¶
 200          void charge_handle(void)
 201          {
 202   1          static u8 cur_adc_ref = CUR_ADC_REF_2_0_VOL; // 0 -- 2.0Vå‚è€ƒï¼Œ1 -- 3.0Vå‚è€ƒ
 203   1          // ä½¿ç”¨2Vå‚è€ƒç”µå‹ï¼Œå¦‚æœæ£€æµ‹åˆ°å……ç”µç”µå‹å¤§äº4.90Vï¼Œæ”¹ä¸º3.0Vå‚è€ƒ
 204   1          // ä½¿ç”¨3.0Vå‚è€ƒæ—¶ï¼Œå¦‚æœæ£€æµ‹åˆ°å……ç”µç”µå‹å°äº4.0Vï¼Œæ”¹ä¸º2.0Vå‚è€ƒç”µå‹
 205   1      
 206   1          if (CUR_ADC_REF_2_0_VOL == cur_adc_ref)
 207   1          {
 208   2              adc_sel_pin_charge(CUR_ADC_REF_2_0_VOL);
 209   2              charging_adc_val = adc_getval();
 210   2      
 211   2              // if (charging_adc_val )
 212   2          }
 213   1          // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
 214   1          // charging_adc_val = adc_getval(); // é‡‡é›†å……ç”µè¾“å…¥å¯¹åº”çš„adå€¼
 215   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     22    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
