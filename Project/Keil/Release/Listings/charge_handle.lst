C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     06/23/2025 11:05:11 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CHARGE_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\charge_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\charge_handle.c OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\charge_h
                    -andle.lst) OBJECT(.\Release\Objects\charge_handle.obj)

line level    source

   1          #include "charge_handle.h"
   2          
   3          volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE;
   4          
   5          // å……ç”µæ§åˆ¶
   6          void charge_handle(void)
   7          {
   8   1          // static volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE; // æµ‹è¯•ç”¨
   9   1      
  10   1          /*
  11   1              æ ‡å¿—ä½ï¼Œæ˜¯å¦ä½¿èƒ½å……ç”µï¼Œç”¨äºæ§åˆ¶å……æ»¡ç”µåï¼Œç­‰åˆ°å……ç”µç”µå‹å°äºä¸€å®šå€¼ä¹‹å
             -ï¼Œå†ä½¿èƒ½å……ç”µ
  12   1              0 -- ä¸ä½¿èƒ½å……ç”µ
  13   1              1 -- ä½¿èƒ½å……ç”µ
  14   1          */
  15   1          static volatile u8 flag_is_enable_charging = 0;
  16   1      
  17   1          volatile u16 charging_adc_val;
  18   1          volatile u16 bat_adc_val;
  19   1      
  20   1          adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  21   1          charging_adc_val = adc_getval(); // é‡‡é›†å……ç”µè¾“å…¥å¯¹åº”çš„adå€¼
  22   1          adc_sel_pin(ADC_PIN_DETECT_BATTERY);
  23   1          bat_adc_val = adc_getval(); // é‡‡é›†ç”µæ± ç”µå‹å¯¹åº”çš„adå€¼
  24   1      
  25   1      #if 0
                  {
                      static u16 cnt = 0;
                      cnt++;
                      if (cnt >= 100)
                      {
                          cnt = 0;
                          printf("cur_charging_adc_val : %u\n", charging_adc_val);
                          // printf("cur_bat_adc_val : %u\n", bat_adc_val);
              
                          // printf("detect vol of charge: %u mV\n", (u16)((u32)charging_adc_val * 2 * 11000 / 4096));
                          // printf("detect vol of bat: %u mV\n", (u16)((u32)bat_adc_val * 2 * 2 * 1000 / 4096));
                      }
                  }
              #endif
  40   1      
  41   1      #if 1
  42   1          // å¦‚æœå½“å‰æœªåœ¨å……ç”µ
  43   1          if (CUR_CHARGE_STATUS_NONE == cur_charge_status)
  44   1          {
  45   2      
  46   2              if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END) /* å¦‚æœå……ç”µç”µå‹è¿‡å° */
  47   2              {
  48   3                  flag_is_enable_charging = 1; // ä½¿èƒ½å……ç”µ
  49   3              }
  50   2      
  51   2              if (charging_adc_val >= ADC_VAL_ENABLE_IN_CHARGE_END)
  52   2              {
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     06/23/2025 11:05:11 PAGE 2   

  53   3                  // å¦‚æœåœ¨æœªå……ç”µæ—¶ï¼Œæ£€æµ‹åˆ°å……ç”µè¾“å…¥ç”µå‹è€Œä½¿èƒ½å……ç”µ
  54   3      
  55   3                  if (flag_is_enable_charging) // å¦‚æœä½¿èƒ½äº†å……ç”µ
  56   3                  {
  57   4                      cur_charge_status = CUR_CHARGE_STATUS_IN_CHARGING;
  58   4                      printf("in charging\n");
  59   4                  }
  60   3              }
  61   2          }
  62   1          else // å¦‚æœå½“å‰æ­£åœ¨å……ç”µ
  63   1          {
  64   2              static u8 cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  65   2      
  66   2              if (charging_adc_val <= ADC_VAL_DISABLE_IN_CHARGE_END || /* å¦‚æœå……ç”µç”µå‹è¿‡å° */
  67   2                  // charging_adc_val >= 2420 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 13V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™·*/
  68   2                  // charging_adc_val >= 2973 || /* å……ç”µè¾“å…¥ç”µå‹å¤§äº 15V ï¼Œæ–­å¼€å……ç”µ ï¼Œå…¬å¼è¿˜æœ‰
             -ç¼ºé™· */
  69   2                  bat_adc_val >= ADC_VAL_BAT_IS_FULL) /* å¦‚æœç”µæ± å·²ç»æ»¡ç”µ */
  70   2              {
  71   3                  // å……ç”µè¾“å…¥çš„ç”µå‹å°äºä¸€å®šå€¼ï¼Œæ–­å¼€å……ç”µ
  72   3                  // ç”µæ±  å·²ç»æ»¡ç”µï¼Œ æ–­å¼€å……ç”µ
  73   3                  // timer0_pwm_disable();
  74   3                  PWM_CTL_FOR_CHARGING_DISABLE();
  75   3                  cur_charge_status = CUR_CHARGE_STATUS_NONE;
  76   3                  cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  77   3      
  78   3                  printf("disable charge\n");
  79   3                  return;
  80   3              }
  81   2      
  82   2              // è¿›è¡Œæ¶“æµå……ç”µï¼š
  83   2              if (bat_adc_val <= ADC_VAL_BAT_IS_LOW || /* å¦‚æœç”µæ± ç”µå‹å°äºä¸€å®šå€¼ */
  84   2                  // bat_adc_val >= ADC_VAL_BAT_IS_NEAR_FULL || /* å¦‚æœç”µæ± ç”µå‹å¤§äºä¸€å®šå€¼ */
  85   2                  charging_adc_val < 930) /* å……ç”µç”µå‹å°äº5V */
  86   2              {
  87   3                  if (CUR_CHARGING_PWM_STATUS_LOW_FEQ != cur_charging_pwm_status)
  88   3                  {
  89   4                      // timer0_pwm_set_low_feq(); // å‡½æ•°å†…éƒ¨è®¾å®šäº†å›ºå®šé¢‘ç‡å’Œå›ºå®šå ç©ºæ¯”
  90   4                      PWM_CTL_FOR_CHARGING_SET_LOW_FEQ();
  91   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
  92   4      
  93   4                      printf("low feq charge\n");
  94   4                  }
  95   3              }
  96   2              else // å¦‚æœç”µæ± ç”µå‹ä¸æ˜¯åœ¨æ¶“æµå……ç”µçš„èŒƒå›´
  97   2              {
  98   3                  u32 tmp;
  99   3      
 100   3                  // å¦‚æœç”µæ± ç”µå‹ä¸åœ¨æ¶“æµå……ç”µçš„åŒºé—´ï¼Œåˆ™æ­£å¸¸å……ç”µ
 101   3                  // æ³¨æ„è¿™é‡Œä¸èƒ½éšæ„æ”¹å˜ PWMå ç©ºæ¯”ï¼Œæœ€å¥½è®¾ç½®PWMå ç©ºæ¯”ä¸º0
 102   3                  if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ != cur_charging_pwm_status)
 103   3                  {
 104   4                      // timer0_pwm_set_high_feq();
 105   4                      PWM_CTL_FOR_CHARGING_SET_HIGH_FEQ();
 106   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_HIGH_FRQ;
 107   4                  }
 108   3      
 109   3                  // æ ¹æ®å……ç”µç”µå‹è°ƒæ•´pwmå ç©ºæ¯”
 110   3      
 111   3                  // æ­£å¸¸å……ç”µæ—¶ï¼Œæ‰è°ƒèŠ‚æ§åˆ¶å……ç”µçš„PWMå ç©ºæ¯”
 112   3                  if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ == cur_charging_pwm_status)
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     06/23/2025 11:05:11 PAGE 3   

 113   3                  {
 114   4                      /*
 115   4                             æµ‹å¾—æ ·æœºå……ç”µæ§åˆ¶çš„åŠŸèƒ½ï¼š
 116   4                             5Vè¾“å…¥ï¼Œpwm 105Khzï¼Œ90%ï¼Œï¼ˆå¯èƒ½è¦ä½¿ç”¨ 105Khzï¼Œ85%ï¼‰ï¼›12Vè¾“å…¥ï¼Œpwm 
             -105Khzï¼Œ30%
 117   4                             ç”¨ï¼ˆ5Vï¼Œ85%ï¼‰å’Œï¼ˆ12Vï¼Œ30%ï¼‰è¿™ä¸¤ä¸ªç‚¹æ¥è®¡ç®—ï¼Œ
 118   4                             å·²çŸ¥ä¸¤ç‚¹åæ ‡(5,85),(12,30)ï¼Œæ±‚å¯¹åº”çš„æ–¹ç¨‹ï¼Œ
 119   4                             å¯¹åº”ç›´çº¿çš„æ–¹ç¨‹ï¼š y  =  -7.857x  + 124.286
 120   4                             y å¯¹åº”å ç©ºæ¯”ï¼Œå•ä½ï¼š%ï¼›x å¯¹åº”å……ç”µè¾“å…¥ç”µå‹ï¼Œå•ä½ï¼šV
 121   4                             åœ¨å…¬å¼ä¸Šå»æ‰å°æ•°ç‚¹ï¼š
 122   4                             1000y = -7857x + 124286
 123   4      
 124   4                             å•ç‰‡æœºadcä½¿ç”¨å†…éƒ¨2.0Vå‚è€ƒç”µå‹ï¼Œ
 125   4                             å°†å…¬å¼è½¬æ¢æˆ å ç©ºæ¯” å’Œ adå€¼ çš„å…³ç³»:
 126   4                             å¤–éƒ¨å……ç”µè¾“å…¥çš„ç”µå‹ 1/11 åˆ†å‹åï¼Œåˆ°å•ç‰‡æœºæ£€æµ‹è„š
 127   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ / 11 / å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 4096 == å•ç‰‡æœºé‡‡é›†åˆ°çš„a
             -då€¼
 128   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ / 4096 * å•ç‰‡æœºadcå‚è€ƒç”µå‹ 
             -* 11
 129   4                             æ¢ç®—æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
 130   4                             å¤–éƒ¨è¾“å…¥ç”µå‹ == å•ç‰‡æœºé‡‡é›†åˆ°çš„adå€¼ * å•ç‰‡æœºadcå‚è€ƒç”µå‹ * 11 / 
             -4096
 131   4                             x = adc_val * 2 * 11 / 4096
 132   4      
 133   4                             å¾—åˆ°çš„å…¬å¼ï¼š
 134   4                             1000y = 124286 - 7857 (adc_val * 2 * 11 / 4096)
 135   4                             1000y = 124286 - adc_val * 7857 * 2 * 11 / 4096
 136   4                             è¿™ä¸ªå…¬å¼è¿ç®—ä¸ä¼šè¶…å‡º 2^32 èŒƒå›´
 137   4                         */
 138   4                      tmp = (u32)124286 - (u32)charging_adc_val * 7857 * 2 * 11 / 4096;
 139   4                      // å¾—åˆ°çš„ tmp æ˜¯1000å€çš„å ç©ºæ¯”å€¼ï¼Œéœ€è¦é™¤ä»¥1000ï¼Œ å†ä¹˜ä»¥ å®šæ—¶å™¨é‡è½½
             -å€¼/100,å¾—åˆ°å®šæ—¶å™¨å¯¹åº”çš„å ç©ºæ¯”å€¼
 140   4                      // T1DATA = (u32)T1LOAD * (u32)tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 141   4                      {
 142   5                          static u16 cnt = 0;
 143   5                          cnt++;
 144   5                          if (cnt >= 100)
 145   5                          {
 146   6                              cnt = 0;
 147   6                              printf("cur pwm percent : %lu %%\n", (u32)tmp / 1000);
 148   6                              // printf("cal val  : %lu \n", (u32)charging_adc_val * 7857 * 2 * 11 / 4096);
 149   6                          }
 150   5                      }
 151   4      
 152   4                      // tmp = (((u32)TMR1_PRH << 8) | (u32)TMR1_PRL) * (u32)tmp / 1000; // æœ€ç»ˆçš„å ç©ºæ¯”å€
             -¼ï¼ˆç”¨è¿™ä¸ªè®¡ç®—ï¼Œå¾—å‡ºçš„å€¼æ˜¯0ï¼‰
 153   4                      tmp = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 154   4      
 155   4                      /*
 156   4                          ç”±äºå…¬å¼é™åˆ¶ï¼Œå¯èƒ½å……ç”µç”µå‹å¤§äº15Vå°±ä¼šå¯¼è‡´å ç©ºæ¯”å˜ä¸º0ï¼Œç°åœ¨ä
             -¸è®©å®ƒåˆ°0%
 157   4                      */
 158   4                      if (0 == (u16)tmp)
 159   4                      // if (0 == tmp)
 160   4                      {
 161   5                          tmp = 1;
 162   5                      }
 163   4      
 164   4      #if 0
                              {
                                  static u16 cnt = 0;
                                  cnt++;
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     06/23/2025 11:05:11 PAGE 4   

                                  if (cnt >= 100)
                                  {
                                      cnt = 0;
                                      // printf("reg val : %u \n", (u16)tmp);
                                      // printf("reg val : %u \n", (u16)(((u32)TMR1_PRH << 8) | (u32)TMR1_PRL));
                                      // printf("reg val : %u \n", (u16)((u32)TIMER1_HIGH_FEQ_PEROID_VAL * tmp / 1000 / 
             -100));
                                  }
                              }
              #endif
 177   4      
 178   4                      TMR1_PWMH = (tmp >> 8) & 0xFF;
 179   4                      TMR1_PWML = tmp & 0xFF;
 180   4                  }
 181   3              }
 182   2          }
 183   1      #endif
 184   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    366    ----
   CONSTANT SIZE    =     71    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
