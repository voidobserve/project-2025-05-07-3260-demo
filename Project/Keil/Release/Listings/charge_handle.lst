C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CHARGE_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\charge_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\charge_handle.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\ch
                    -arge_handle.lst) OBJECT(.\Release\Objects\charge_handle.obj)

line level    source

   1          #include "charge_handle.h"
   2          
   3          // volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE;
   4          
   5          // å……ç”µæ§åˆ¶
   6          void charge_handle(void)
   7          {
   8   1      
   9   1          if (flag_is_charging_adjust_time_come) // ä¸€å®šè¦åŠ å…¥ç¼“æ…¢è°ƒèŠ‚ï¼Œä¸èƒ½è¿…é€Ÿè°ƒèŠ‚ï¼Œå¦åˆ™ä¼š
             -ç­‰ä¸åˆ°ç”µå‹ç¨³å®š
  10   1          {
  11   2              u16 current = 0; // å……ç”µç”µæµï¼Œå•ä½ï¼šmA
  12   2              // u16 voltage_of_charging = 0; // å……ç”µç”µå‹ï¼Œå•ä½ï¼šmV
  13   2              u16 voltage_of_bat = 0; // ç”µæ± ç”µå‹
  14   2              u32 power = 0;          // åŠŸç‡ï¼Œå•ä½ï¼šmW æ¯«ç“¦
  15   2              static u8 pwm_duty = 0; //
  16   2              u16 pwm_reg = 0;        // å­˜æ”¾è¦å†™å…¥åˆ°å¯„å­˜å™¨ä¸­çš„å ç©ºæ¯”å€¼
  17   2      
  18   2              u16 expected_power = 0; // æœŸæœ›åŠŸç‡
  19   2      
  20   2              flag_is_charging_adjust_time_come = 0; // æ¸…é™¤æ ‡å¿—ä½
  21   2      
  22   2              // å¦‚æœå½“å‰æ²¡æœ‰åœ¨å……ç”µ
  23   2              if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
  24   2              {
  25   3                  adc_sel_ref_voltage(ADC_REF_2_0_VOL); // 2Vå‚è€ƒç”µå‹
  26   3                  adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  27   3                  charging_adc_val = adc_getval();
  28   3      
  29   3                  // å¦‚æœå……ç”µè¾“å…¥ç”µå‹å¤§äº4.9Vï¼Œä½¿èƒ½å……ç”µ
  30   3                  if (charging_adc_val >= (u16)((u32)4900 * 4096 / 11 / 2 / 1000))
  31   3                  {
  32   4                      cur_charge_phase = CUR_CHARGE_PHASE_TRICKLE_CHARGE; // åˆšè¿›å…¥å……ç”µï¼Œé»˜è®¤æ˜¯ç”µæ± ç”
             -µé‡ä½å¯¹åº”çš„æ¶“æµå……ç”µ
  33   4                  }
  34   3      
  35   3                  adc_sel_pin(ADC_PIN_DETECT_BATTERY);
  36   3                  bat_adc_val = adc_getval();
  37   3                  if (bat_adc_val >= (u16)((u32)(3600 - 50) * 4096 / 2 / 2 / 1000))
  38   3                  {
  39   4                      // æ£€æµ‹åˆ°ç”µæ± ç”µå‹å¤§äº3.6 - 0.05V
  40   4                      // ä¸ä½¿èƒ½å……ç”µ
  41   4                      cur_charge_phase = CUR_CHARGE_PHASE_NONE;
  42   4                  }
  43   3      
  44   3                  // å¦‚æœå……ç”µç”µå‹æœªæ»¡è¶³ä½¿èƒ½å……ç”µçš„æ¡ä»¶ï¼Œä¼šè¿›å…¥ä¸‹é¢çš„è¯­å¥å—
  45   3                  if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
  46   3                  {
  47   4                      return;
  48   4                  }
  49   3              }
  50   2              else
  51   2              {
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 2   

  52   3                  // å¦‚æœå½“å‰åœ¨å……ç”µ
  53   3                  adc_sel_ref_voltage(ADC_REF_3_0_VOL); // 3Vå‚è€ƒç”µå‹
  54   3                  adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  55   3                  charging_adc_val = adc_getval();
  56   3      
  57   3                  // å¦‚æœå……ç”µç”µå‹è¿‡å¤§ï¼ŒPWMç™¾åˆ†æ¯”è®¾ç½®ä¸º0ï¼Œç­‰åˆ°ç”µå‹å˜å°æ‰æ‰“å¼€
  58   3                  // if (charging_adc_val >= (u16)((u32)30000 * 4096 / 11 / 3 / 1000)) // å……ç”µç”µå‹è¶…è¿‡30V
  59   3                  if (charging_adc_val >= (u16)((u32)28000 * 4096 / 11 / 3 / 1000)) // å……ç”µç”µå‹è¶…è¿‡ xx V
  60   3                  {
  61   4                      pwm_reg = 0;
  62   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  63   4                      TMR1_PWML = pwm_reg & 0xFF;
  64   4                      return;
  65   4                  }
  66   3      
  67   3                  // å¦‚æœå……ç”µè¾“å…¥ç”µå‹å°äº4Vï¼Œæ–­å¼€å……ç”µ
  68   3                  if (charging_adc_val <= (u16)((u32)4000 * 4096 / 11 / 3 / 1000))
  69   3                  {
  70   4                      pwm_reg = 0;
  71   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  72   4                      TMR1_PWML = pwm_reg & 0xFF;
  73   4                      timer1_pwm_disable();
  74   4      
  75   4                      cur_charge_phase = CUR_CHARGE_PHASE_NONE;
  76   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  77   4                      return;
  78   4                  }
  79   3      
  80   3                  // å¦‚æœå·²ç»å……æ»¡ç”µï¼Œç›´æ¥é€€å‡º
  81   3                  if (CUR_CHARGE_PHASE_FULLY_CHARGE == cur_charge_phase)
  82   3                  {
  83   4                      return;
  84   4                  }
  85   3      
  86   3                  // å¯èƒ½æ˜¯å¯¹åº”çš„MOSç®¡æœªä½¿èƒ½ï¼Œå¯¼è‡´å……ç”µç”µæµå°ï¼Œä¸æ˜¯æ¶“æµå……ç”µï¼š
  87   3                  // if (charging_adc_val <= (u16)((u32)4900 * 4096 / 11 / 3 / 1000)) // å°äº4.9Vï¼Œè¿›è¡Œæ¶“æ
             -µå……ç”µ
  88   3                  // {
  89   3                  //     pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
  90   3                  //     TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  91   3                  //     TMR1_PWML = pwm_reg & 0xFF;
  92   3                  //     timer1_set_pwm_low_feq();
  93   3                  //     cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
  94   3                  //     return;
  95   3                  // }
  96   3              }
  97   2      
  98   2              // è¿›å…¥åˆ°è¿™é‡Œï¼Œè¯´æ˜æ­£åœ¨å……ç”µï¼Œä¸”å……ç”µç”µå‹åœ¨ 4V~30Vä¹‹é—´ï¼Œä¸åŒ…æ‹¬4Vå’Œ30V
  99   2      
 100   2              // æ£€æµ‹ç”µæ± ç”µå‹ï¼Œä½¿ç”¨å†…éƒ¨2.0Vå‚è€ƒç”µå‹
 101   2              adc_sel_ref_voltage(ADC_REF_2_0_VOL);
 102   2              adc_sel_pin(ADC_PIN_DETECT_BATTERY);
 103   2              bat_adc_val = adc_getval();
 104   2      
 105   2              // åˆšè¿›å…¥å……ç”µï¼Œä¼šè¿›å…¥ä¸‹é¢è¿™ä¸ªè¯­å¥å—ï¼š
 106   2              if (CUR_CHARGE_PHASE_TRICKLE_CHARGE == cur_charge_phase)
 107   2              {
 108   3                  // å¦‚æœç”µæ± ç”µå‹å°äº2.7Vï¼Œè¿›è¡Œæ¶“æµå……ç”µ
 109   3                  if (bat_adc_val <= (u16)((u32)2700 * 4096 / 2 / 2 / 1000))
 110   3                  {
 111   4                      if (CUR_CHARGING_PWM_STATUS_LOW_FEQ != cur_charging_pwm_status)
 112   4                      {
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 3   

 113   5                          pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 114   5                          TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 115   5                          TMR1_PWML = pwm_reg & 0xFF;
 116   5                          timer1_set_pwm_low_feq();
 117   5                          cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
 118   5                      }
 119   4      
 120   4                      return;
 121   4                  }
 122   3      
 123   3                  // å¦‚æœç”µæ± ç”µå‹ä¸å°äº2.7Vï¼Œè¿›è¡Œæ­£å¸¸å……ç”µ
 124   3                  cur_charge_phase = CUR_CHARGE_PHASE_NORMAL_CHARGE;
 125   3              }
 126   2      
 127   2              // TODO:
 128   2              // ç”µæ± ç”µå‹å¤§äº xx Vï¼Œä»æ­£å¸¸å……ç”µå˜ä¸ºæ¶“æµå……ç”µ
 129   2              if ((bat_adc_val >= (u16)((u32)3700 * 4096 / 2 / 2 / 1000)) &&
 130   2                  (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE != cur_charge_phase))
 131   2              {
 132   3                  pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 133   3                  TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 134   3                  TMR1_PWML = pwm_reg & 0xFF;
 135   3                  timer1_set_pwm_low_feq();
 136   3                  cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
 137   3                  cur_charge_phase = CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE;
 138   3              }
 139   2      
 140   2              // å¦‚æœå……ç”µé˜¶æ®µå·²ç»åˆ°äº†ç”µæ± æ¥è¿‘æ»¡ç”µçš„é˜¶æ®µ
 141   2              if (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE == cur_charge_phase)
 142   2              {
 143   3                  static u8 fully_charge_cnt = 0;
 144   3      
 145   3                  // adc_sel_ref_voltage(ADC_REF_2_0_VOL);
 146   3      
 147   3                  if (flag_is_tim_turn_off_pwm)
 148   3                  {
 149   4                      // å¦‚æœåœ¨æ¶“æµå……ç”µçš„ æ–­å¼€å……ç”µæœŸé—´
 150   4                      bat_adc_val = adc_getval();
 151   4                      if (bat_adc_val >= (u16)((u32)3600 * 4096 / 2 / 2 / 1000))
 152   4                      {
 153   5                          // æ£€æµ‹åˆ°ç”µæ± ç”µå‹å¤§äº3.6V
 154   5                          fully_charge_cnt++;
 155   5                      }
 156   4      
 157   4                      if (fully_charge_cnt >= 10)
 158   4                      {
 159   5                          fully_charge_cnt = 0;
 160   5      
 161   5                          pwm_reg = 0;
 162   5                          TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 163   5                          TMR1_PWML = pwm_reg & 0xFF;
 164   5                          timer1_pwm_disable();
 165   5      
 166   5                          cur_charge_phase = CUR_CHARGE_PHASE_FULLY_CHARGE; // è¡¨ç¤ºå·²ç»å……æ»¡ç”µï¼Œæ¥ä¸‹æ¥
             -éœ€è¦ç­‰å……ç”µç”µå‹ä½äº4.0V
 167   5                          cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
 168   5                      }
 169   4                  }
 170   3                  else
 171   3                  {
 172   4                      fully_charge_cnt = 0;
 173   4                  }
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 4   

 174   3      
 175   3                  // TODOï¼š
 176   3                  if (bat_adc_val >= (u16)((u32)3700 * 4096 / 2 / 2 / 1000))
 177   3                  {
 178   4                      // å¦‚æœä¹‹å‰æ£€æµ‹åˆ°ç”µæ± ç”µå‹å¤§äº xx Vï¼Œå¹¶ä¸”è¿˜åœ¨æ¶“æµå……ç”µï¼Œç«‹å³åœæ­¢å
             -……ç”µ
 179   4                      pwm_reg = 0;
 180   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 181   4                      TMR1_PWML = pwm_reg & 0xFF;
 182   4                      timer1_pwm_disable();
 183   4      
 184   4                      cur_charge_phase = CUR_CHARGE_PHASE_FULLY_CHARGE; // è¡¨ç¤ºå·²ç»å……æ»¡ç”µï¼Œæ¥ä¸‹æ¥éœ€è
             -¦ç­‰å……ç”µç”µå‹ä½äº4.0V
 185   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
 186   4                      fully_charge_cnt = 0;
 187   4                  }
 188   3      
 189   3                  return;
 190   3              }
 191   2      
 192   2              // ===================================================================
 193   2              // ä»¥ä¸‹éƒ½æ˜¯æ­£å¸¸å……ç”µå¯¹åº”çš„æ§åˆ¶ç¨‹åºï¼Œcur_charge_phase == CUR_CHARGE_PHASE_NORMAL_CHA
             -RGE
 194   2              // ===================================================================
 195   2      
 196   2              // ä¸æ˜¯æ­£å¸¸å……ç”µï¼Œæå‰è¿”å›
 197   2              if (CUR_CHARGE_PHASE_NORMAL_CHARGE != cur_charge_phase)
 198   2              {
 199   3                  return;
 200   3              }
 201   2      
 202   2              // å¦‚æœPWMæœªåˆ‡æ¢åˆ°é«˜é¢‘
 203   2              if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ != cur_charging_pwm_status)
 204   2              {
 205   3                  pwm_reg = 0;
 206   3                  TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 207   3                  TMR1_PWML = pwm_reg & 0xFF;
 208   3                  timer1_set_pwm_high_feq();
 209   3                  cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_HIGH_FRQ;
 210   3              }
 211   2      
 212   2              // å¦‚æœæœ‰ä¸€æ¬¡ç”µæ± ç”µå‹è¶…è¿‡3.5V
 213   2              // if (bat_adc_val >= (u16)((u32)3500 * 4096 / 2 / 2 / 1000))
 214   2              if (bat_adc_val >= (u16)((u32)3400 * 4096 / 2 / 2 / 1000))
 215   2              {
 216   3                  // expected_power = 24000; // å®é™…æµ‹è¯•20Wä¸åˆ°ï¼Œæ¥è¿‘20W
 217   3                  // expected_power = 20000; //
 218   3                  // expected_power = 10000; // ç”µæµå¾ˆå¤§
 219   3                  expected_power = 5000; // 
 220   3                  // expected_power = 1000; // ç”µæµå¤ªå°ï¼ŒPWMå ç©ºæ¯”ä¹Ÿå°
 221   3              }
 222   2              else // å¦‚æœç”µæ± ç”µå‹ä¸è¶…è¿‡3.5V
 223   2              {
 224   3                  // if (expected_power != 24000)
 225   3                  {
 226   4                      // expected_power = 27000; // å®é™…æµ‹è¯•çº¦30W
 227   4                      expected_power = 26500; 
 228   4                  }
 229   3              }
 230   2      
 231   2              adc_sel_ref_voltage(ADC_REF_3_0_VOL);
 232   2              adc_sel_pin(ADC_PIN_DETECT_CURRENT);
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 5   

 233   2              current_adc_val = adc_getval();
 234   2      
 235   2              /*
 236   2                  æ£€æµ‹ç”µæµå¼•è„šæ£€æµ‹åˆ°çš„ç”µå‹ == adå€¼ / 4096 * å‚è€ƒç”µå‹
 237   2                  current_adc_val * 3 / 4096
 238   2      
 239   2                  æ£€æµ‹ç”µæµçš„å¼•è„šæ£€æµ‹åˆ°çš„å……ç”µç”µæµ == æ£€æµ‹ç”µæµå¼•è„šæ£€æµ‹åˆ°çš„ç”µå‹ / 110(è¿
             -æ”¾æ”¾å¤§å€æ•°) / 0.005Rï¼Œ
 240   2                  é€æ­¥æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
 241   2                  current_adc_val * 3 / 4096 / 110 / 0.005
 242   2                  current_adc_val * 3 / 4096 / 110 * 1000 / 5
 243   2                  current_adc_val * 3 * 1000 / 5 / 4096 / 110
 244   2                  å¾—åˆ°çš„æ˜¯ä»¥Aä¸ºå•ä½çš„ç”µæµï¼Œéœ€è¦å†è½¬æ¢æˆä»¥mAä¸ºå•ä½ï¼š
 245   2                  current_adc_val * 3 * 1000 * 1000 / 5 / 4096 / 110ï¼Œè®¡ç®—ä¼šæº¢å‡ºï¼Œéœ€è¦å†åŒ–ç®€
 246   2                  (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 110
 247   2                  current =  (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 110;
 248   2              */
 249   2              current = (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 76; // 
 250   2      
 251   2              /*
 252   2                  è®¡ç®—å……ç”µç”µå‹
 253   2              */
 254   2              // voltage_of_charging = (u32)charging_adc_val * 3 * 1000 * 11 / 4096;
 255   2              /*
 256   2                  è®¡ç®—ç”µæ± ç”µå‹
 257   2                  ç”µæ± ç”µå‹ï¼ˆmVï¼‰ == é‡‡é›†åˆ°çš„adå€¼ / 4096 * å‚è€ƒç”µå‹ * åˆ†å‹ç³»æ•° * 1000ï¼ˆmVï¼‰
 258   2              */
 259   2              voltage_of_bat = (u32)bat_adc_val * 2 * 1000 * 2 / 4096;
 260   2      
 261   2              // å¦‚æœæ£€æµ‹åˆ°ç”µæµçš„adå€¼å·²ç»çˆ†è¡¨
 262   2              if (current_adc_val >= 4095)
 263   2              // if (current >= 5400) // å¦‚æœç”µæµå€¼å·²ç»çˆ†è¡¨ï¼Œè¶…è¿‡å•ç‰‡æœºèƒ½æ£€æµ‹çš„å€¼ï¼š5454.54
 264   2              {
 265   3                  // printf("current overflow\n");
 266   3                  if (pwm_duty > 0)
 267   3                  {
 268   4                      pwm_duty--;
 269   4                  }
 270   3              }
 271   2              else //
 272   2              {
 273   3                  // power = voltage_of_charging * current / 1000; // 1000mV * 1000mA == 1000000 (1 Watt)
 274   3                  power = (u32)voltage_of_bat * current / 1000; // 1000mV * 1000mA == 1000000 (1 Watt)
 275   3      
 276   3                  // å‡è®¾å……ç”µæœ‰20%çš„æŸè€—ï¼Œå……ç”µè¾“å‡º30Wï¼Œæµå…¥ç”µæ± 24W
 277   3                  // printf("power %lu \n", power);
 278   3                  // if (power < 30000) // 30 * 1000 mWï¼ˆå®é™…æµ‹å¾—è¿™é‡Œè¦æ¯”30Wè¿˜å¤§ï¼Œæœªè€ƒè™‘ä¸Šå‹é™
             -ï¼‰
 279   3                  // if (power < 27000) // xx * 1000 mWï¼ˆå®é™…æµ‹è¯•çº¦24.6Wï¼‰
 280   3                  // if (power < 24000) // xx * 1000 mWï¼ˆå®é™…æµ‹è¯•ä¸åˆ°20Wï¼Œæ¥è¿‘20Wï¼‰
 281   3                  // if (power < 20000) // xx * 1000 mW
 282   3                  // if (power == 0) // è¿™ç§æƒ…å†µæœªè€ƒè™‘
 283   3                  // {
 284   3      
 285   3                  // }
 286   3                  // else if (power < expected_power)
 287   3                  
 288   3                  if (power < expected_power)
 289   3                  {
 290   4                      if (pwm_duty < 100)
 291   4                      {
 292   5                          pwm_duty++;
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/14/2025 17:10:29 PAGE 6   

 293   5                      }
 294   4                  }
 295   3                  // else if (power > 30000)
 296   3                  // else if (power > 27000) // ï¼ˆå®é™…æµ‹è¯•çº¦24.6Wï¼‰
 297   3                  // else if (power > 24000) // ï¼ˆå®é™…æµ‹è¯•ä¸åˆ°20Wï¼Œæ¥è¿‘20Wï¼‰
 298   3                  // else if (power > 20000)
 299   3                  else if (power > expected_power)
 300   3                  {
 301   4                      if (pwm_duty > 0)
 302   4                      {
 303   5                          pwm_duty--;
 304   5                      }
 305   4                  }
 306   3                  else // power == ç›®æ ‡å€¼ï¼Œä¸åšè°ƒèŠ‚
 307   3                  {
 308   4                  }
 309   3              }
 310   2      
 311   2              // printf("pwm_duty : %bu %%\n", pwm_duty);
 312   2              pwm_reg = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 313   2      
 314   2              //     // printf("pwm_duty :%u\n", pwm_duty);
 315   2              TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 316   2              TMR1_PWML = pwm_reg & 0xFF;
 317   2          }
 318   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    942    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
