C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE CHARGE_HANDLE
OBJECT MODULE PLACED IN .\Release\Objects\charge_handle.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\charge_handle.c LARGE OPTIMIZE(8,SPEED) BROWSE INTVECTOR(0X00
                    -0C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Listings\ch
                    -arge_handle.lst) OBJECT(.\Release\Objects\charge_handle.obj)

line level    source

   1          #include "charge_handle.h"
   2          
   3          // volatile u8 cur_charge_status = CUR_CHARGE_STATUS_NONE;
   4          
   5          #include "my_debug.h"
   6          
   7          #define MIN_PWM_DUTY_IN_LOW_POWER (8)      // å¿«æ»¡ç”µè€Œé™ä½å……ç”µåŠŸç‡æ—¶ï¼Œæœ€ä½çš„å ç©ºæ¯”ï¼Œå•
             -ä½ï¼š1%
   8          #define MIN_PWM_DUTY_IN_TRICKLE_CHARGE (5) // æ¶“æµå……ç”µæ—¶ï¼Œæœ€ä½çš„å ç©ºæ¯”ï¼Œå•ä½ï¼š1%
   9          
  10          // å……ç”µæ§åˆ¶
  11          void charge_handle(void)
  12          {
  13   1          if (flag_is_charging_adjust_time_come) // ä¸€å®šè¦åŠ å…¥ç¼“æ…¢è°ƒèŠ‚ï¼Œä¸èƒ½è¿…é€Ÿè°ƒèŠ‚ï¼Œå¦åˆ™ä¼š
             -ç­‰ä¸åˆ°ç”µå‹ç¨³å®š
  14   1          {
  15   2              static u8 pwm_duty = 0; // å•ä½ï¼š1%
  16   2      
  17   2              // æ£€æµ‹åˆ°ç”µæ± å¿«æ»¡ç”µï¼Œæ˜¯å¦è¿›å…¥æ¶“æµå……ç”µçš„è®¡æ•°
  18   2              static u8 trickle_charge_cnt = 0;
  19   2              // static u8 limited_pwm_duty = 0;
  20   2      
  21   2              u16 current = 0;        // å……ç”µç”µæµï¼Œå•ä½ï¼šmA
  22   2              u16 voltage_of_bat = 0; // ç”µæ± ç”µå‹ï¼Œå•ä½ï¼šmV
  23   2              u32 power = 0;          // åŠŸç‡ï¼Œå•ä½ï¼šmW æ¯«ç“¦
  24   2              u16 pwm_reg = 0;        // å­˜æ”¾è¦å†™å…¥åˆ°å¯„å­˜å™¨ä¸­çš„å ç©ºæ¯”å€¼
  25   2              u16 expected_power = 0; // æœŸæœ›åŠŸç‡ ï¼Œå•ä½ï¼šmW æ¯«ç“¦
  26   2      
  27   2              flag_is_charging_adjust_time_come = 0; // æ¸…é™¤æ ‡å¿—ä½
  28   2      
  29   2              // å¦‚æœå½“å‰æ²¡æœ‰åœ¨å……ç”µ
  30   2              if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
  31   2              {
  32   3                  // adc_sel_ref_voltage(ADC_REF_2_0_VOL); // 2Vå‚è€ƒç”µå‹
  33   3                  // adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  34   3                  // charging_adc_val = adc_getval();
  35   3                  adc_update_charge_adc_val(ADC_REF_2_0_VOL);
  36   3      
  37   3                  // å¦‚æœå……ç”µè¾“å…¥ç”µå‹å¤§äº4.9Vï¼Œä½¿èƒ½å……ç”µ
  38   3                  if (charging_adc_val >= (u16)((u32)4900 * 4096 / 11 / 2 / 1000))
  39   3                  {
  40   4                      cur_charge_phase = CUR_CHARGE_PHASE_TRICKLE_CHARGE; // åˆšè¿›å…¥å……ç”µï¼Œé»˜è®¤æ˜¯ç”µæ± ç”
             -µé‡ä½å¯¹åº”çš„æ¶“æµå……ç”µ
  41   4                  }
  42   3      
  43   3                  // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
  44   3                  // bat_adc_val = adc_getval();
  45   3                  // if (bat_adc_val >= (u16)((u32)(3600 - 50) * 4096 / 2 / 2 / 1000))
  46   3                  // {
  47   3                  //     // æ£€æµ‹åˆ°ç”µæ± ç”µå‹å¤§äº3.6 - 0.05V
  48   3                  //     // ä¸ä½¿èƒ½å……ç”µ
  49   3                  //     cur_charge_phase = CUR_CHARGE_PHASE_NONE;
  50   3                  // }
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 2   

  51   3      
  52   3                  // å¦‚æœå……ç”µç”µå‹æœªæ»¡è¶³ä½¿èƒ½å……ç”µçš„æ¡ä»¶ï¼Œä¼šè¿›å…¥ä¸‹é¢çš„è¯­å¥å—
  53   3                  if (CUR_CHARGE_PHASE_NONE == cur_charge_phase)
  54   3                  {
  55   4                      return;
  56   4                  }
  57   3              }
  58   2              else
  59   2              {
  60   3                  // å¦‚æœå½“å‰åœ¨å……ç”µ
  61   3                  adc_sel_ref_voltage(ADC_REF_3_0_VOL); // 3Vå‚è€ƒç”µå‹
  62   3                  adc_sel_pin(ADC_PIN_DETECT_CHARGE);
  63   3                  charging_adc_val = adc_getval();
  64   3      
  65   3                  // å¦‚æœå……ç”µç”µå‹è¿‡å¤§ï¼ŒPWMç™¾åˆ†æ¯”è®¾ç½®ä¸º0ï¼Œç­‰åˆ°ç”µå‹å˜å°æ‰æ‰“å¼€
  66   3                  // if (charging_adc_val >= (u16)((u32)30000 * 4096 / 11 / 3 / 1000)) // å……ç”µç”µå‹è¶…è¿‡30V
  67   3                  if (charging_adc_val >= (u16)((u32)28000 * 4096 / 11 / 3 / 1000)) // å……ç”µç”µå‹è¶…è¿‡ xx V
  68   3                  {
  69   4                      pwm_reg = 0;
  70   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  71   4                      TMR1_PWML = pwm_reg & 0xFF;
  72   4                      return;
  73   4                  }
  74   3      
  75   3                  // å¦‚æœå……ç”µè¾“å…¥ç”µå‹å°äº4Vï¼Œæ–­å¼€å……ç”µ
  76   3                  if (charging_adc_val <= (u16)((u32)4000 * 4096 / 11 / 3 / 1000))
  77   3                  {
  78   4                      pwm_reg = 0;
  79   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  80   4                      TMR1_PWML = pwm_reg & 0xFF;
  81   4                      timer1_pwm_disable();
  82   4      
  83   4                      cur_charge_phase = CUR_CHARGE_PHASE_NONE;
  84   4                      cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
  85   4                      return;
  86   4                  }
  87   3      
  88   3                  // å¦‚æœå·²ç»å……æ»¡ç”µï¼Œç›´æ¥é€€å‡º
  89   3                  if (CUR_CHARGE_PHASE_FULLY_CHARGE == cur_charge_phase)
  90   3                  {
  91   4                      return;
  92   4                  }
  93   3      
  94   3                  // å¯èƒ½æ˜¯å¯¹åº”çš„MOSç®¡æœªä½¿èƒ½ï¼Œå¯¼è‡´å……ç”µç”µæµå°ï¼Œä¸æ˜¯æ¶“æµå……ç”µï¼š
  95   3                  // if (charging_adc_val <= (u16)((u32)4900 * 4096 / 11 / 3 / 1000)) // å°äº4.9Vï¼Œè¿›è¡Œæ¶“æ
             -µå……ç”µ
  96   3                  // {
  97   3                  //     pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
  98   3                  //     TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
  99   3                  //     TMR1_PWML = pwm_reg & 0xFF;
 100   3                  //     timer1_set_pwm_low_feq();
 101   3                  //     cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
 102   3                  //     return;
 103   3                  // }
 104   3              }
 105   2      
 106   2              // è¿›å…¥åˆ°è¿™é‡Œï¼Œè¯´æ˜æ­£åœ¨å……ç”µï¼Œä¸”å……ç”µç”µå‹åœ¨ 4V~30Vä¹‹é—´ï¼Œä¸åŒ…æ‹¬4Vå’Œ30V
 107   2      
 108   2              // æ£€æµ‹ç”µæ± ç”µå‹ï¼Œä½¿ç”¨å†…éƒ¨2.0Vå‚è€ƒç”µå‹
 109   2              // adc_sel_ref_voltage(ADC_REF_2_0_VOL);
 110   2              // adc_sel_pin(ADC_PIN_DETECT_BATTERY);
 111   2              // bat_adc_val = adc_getval();
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 3   

 112   2              adc_update_bat_adc_val();
 113   2      
 114   2              // åˆšè¿›å…¥å……ç”µï¼Œä¼šè¿›å…¥ä¸‹é¢è¿™ä¸ªè¯­å¥å—ï¼š
 115   2              if (CUR_CHARGE_PHASE_TRICKLE_CHARGE == cur_charge_phase)
 116   2              {
 117   3                  // å¦‚æœç”µæ± ç”µå‹å°äº2.7Vï¼Œè¿›è¡Œæ¶“æµå……ç”µ
 118   3                  if (bat_adc_val <= (u16)((u32)2700 * 4096 / 2 / 2 / 1000))
 119   3                  {
 120   4                      if (CUR_CHARGING_PWM_STATUS_LOW_FEQ != cur_charging_pwm_status)
 121   4                      {
 122   5                          pwm_reg = (u32)TIMER1_LOW_FEQ_PEROID_VAL * 13 / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 123   5                          TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 124   5                          TMR1_PWML = pwm_reg & 0xFF;
 125   5                          timer1_set_pwm_low_feq();
 126   5                          cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_LOW_FEQ;
 127   5                      }
 128   4      
 129   4                      return;
 130   4                  }
 131   3      
 132   3                  // å¦‚æœç”µæ± ç”µå‹ä¸å°äº2.7Vï¼Œè¿›è¡Œæ­£å¸¸å……ç”µ
 133   3                  cur_charge_phase = CUR_CHARGE_PHASE_NORMAL_CHARGE;
 134   3              }
 135   2      
 136   2              // TODO:
 137   2              // ç”µæ± ç”µå‹å¤§äº xx Vï¼Œä»æ­£å¸¸å……ç”µå˜ä¸ºæ¶“æµå……ç”µ
 138   2              // if ((bat_adc_val >= (u16)((u32)3400 * 4096 / 2 / 2 / 1000)) &&
 139   2              //     (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE != cur_charge_phase))
 140   2              // if ((bat_adc_val >= (u16)((u32)(3500 + 100) * 4096 / 2 / 2 / 1000)) && /* 3500 + 100 æ¯«ä¼ï¼Œå
             -®é™…æµ‹è¯•åœ¨ ç”µæ± ç”µå‹3.56Vï¼Œå•ç‰‡æœºæ£€æµ‹è„š1.81Véƒ½æ²¡æœ‰è¿›å…¥*/
 141   2              //     (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE != cur_charge_phase))
 142   2              if ((bat_adc_val >= (u16)((u32)(3500 + 50 + 20) * 4096 / 2 / 2 / 1000)) && /* xxx æ¯«ä¼ï¼Œå®é™…æ
             -µ‹è¯•åœ¨ 3.53Vï¼Œå•ç‰‡æœºæ£€æµ‹è„šç”µå‹1.793V*/
 143   2                  (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE != cur_charge_phase))
 144   2              {
 145   3                  trickle_charge_cnt++;
 146   3                  // pwm_duty >>= 1; // å ç©ºæ¯”å˜ä¸ºåŸæ¥çš„1/2ï¼Œå†çœ‹çœ‹ç”µæ± ç”µå‹ä¼šä¸ä¼šå˜å°
 147   3                  // limited_pwm_duty = pwm_duty;
 148   3                  // if (limited_pwm_duty > MIN_PWM_DUTY_IN_TRICKLE_CHARGE)
 149   3                  // {
 150   3                  //     pwm_duty = limited_pwm_duty - MIN_PWM_DUTY_IN_TRICKLE_CHARGE;
 151   3                  // }
 152   3      
 153   3                  if (pwm_duty > MIN_PWM_DUTY_IN_TRICKLE_CHARGE)
 154   3                  {
 155   4                      // pwm_duty  -= MIN_PWM_DUTY_IN_TRICKLE_CHARGE; // -=5ï¼Œè°ƒèŠ‚å¹…åº¦æœ‰ç‚¹å¤§
 156   4                      pwm_duty -= 2;
 157   4                  }
 158   3      
 159   3      #if 0
                          pwm_duty = 0;
                          pwm_reg = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * 0 / 100; // å¯„å­˜å™¨å­˜æ”¾çš„å ç©ºæ¯”å€¼
                          TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
                          TMR1_PWML = pwm_reg & 0xFF;
              #endif
 165   3      
 166   3                  if (trickle_charge_cnt >= 250)
 167   3                  {
 168   4                      trickle_charge_cnt = 0;
 169   4      
 170   4                      // å‡†å¤‡è¿›å…¥æ¶“æµå……ç”µï¼Œè®¾ç½®PWMï¼Œæ ·æœºæœ€å°PWMä¸º4.8%
 171   4                      pwm_duty = MIN_PWM_DUTY_IN_TRICKLE_CHARGE;
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 4   

 172   4                      pwm_reg = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 173   4                      TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 174   4                      TMR1_PWML = pwm_reg & 0xFF;
 175   4      
 176   4                      cur_charge_phase = CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE;
 177   4                  }
 178   3              }
 179   2              else
 180   2              {
 181   3                  trickle_charge_cnt = 0;
 182   3              }
 183   2      
 184   2              // å¦‚æœå……ç”µé˜¶æ®µå·²ç»åˆ°äº†ç”µæ± æ¥è¿‘æ»¡ç”µçš„é˜¶æ®µ
 185   2              if (CUR_CHARGE_PHASE_TRICKLE_CHARGE_WHEN_APPROACH_FULLY_CHARGE == cur_charge_phase)
 186   2              {
 187   3                  // static u8 fully_charge_cnt = 0;
 188   3      
 189   3                  // adc_sel_ref_voltage(ADC_REF_3_0_VOL);
 190   3                  // adc_sel_pin(ADC_PIN_DETECT_CURRENT);
 191   3                  // current_adc_val = adc_getval();
 192   3                  // current = (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 76; //
 193   3      
 194   3      #if 0
                          // if (bat_adc_val < (u16)((u32)(3500) * 4096 / 2 / 2 / 1000))
                          // {
                          //     if (current > 2000) // è®¡ç®—å‡ºæ¥æ˜¯2Aæ’æµå……ç”µ
                          //     {
                          //         if (pwm_duty > 0)
                          //         {
                          //             pwm_duty--;
                          //         }
                          //     }
                          //     else if (current < 2000)
                          //     {
                          //         if (pwm_duty < 100) // 100%å ç©ºæ¯”
                          //         {
                          //             pwm_duty++;
                          //         }
                          //     }
                          // }
                          // else // ç”µæ± ç”µå‹å¤§äº 3.5 V
                          {
                              if (current > 300)
                              {
                                  if (pwm_duty > MIN_PWM_DUTY_IN_TRICKLE_CHARGE)
                                  {
                                      pwm_duty--;
                                  }
                              }
                              else if (current < 300)
                              {
                                  if (pwm_duty < 100) // 100%å ç©ºæ¯”
                                  {
                                      pwm_duty++;
                                  }
                              }
                          }
              #endif
 230   3      
 231   3      #if 0
                          if (bat_adc_val < (u16)((u32)(3500 + 50) * 4096 / 2 / 2 / 1000)) // å¦‚æœç”µæ± ç”µå‹å°äº3.
             -5V
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 5   

                          {
                              // fully_charge_cnt = 0;
                              /*
                                  ä¸èƒ½å›åˆ°æ­£å¸¸è°ƒèŠ‚ï¼Œä¼šå½±å“æŒ‡ç¤ºç¯çš„çŠ¶æ€ï¼Œ
                                  æ ·æœºæ¶“æµæ—¶æŒ‡ç¤ºç¯å…¨éƒ¨å¸¸äº®ï¼Œæ­£å¸¸å……ç”µæ—¶æœ€é«˜ä¸€æ ¼çš„æŒ‡ç¤ºç¯é—ªçƒï¼
             -š
                              */
                              // cur_charge_phase = CUR_CHARGE_PHASE_NORMAL_CHARGE; // å›åˆ°æ­£å¸¸å……ç”µè°ƒèŠ‚
                              // return;
                          }
              #endif
 243   3      
 244   3                  // if (bat_adc_val >= (u16)((u32)(3600 + 150) * 4096 / 2 / 2 / 1000))
 245   3                  if (bat_adc_val >= (u16)((u32)(3600 + 50) * 4096 / 2 / 2 / 1000))
 246   3                  {
 247   4      
 248   4                      // fully_charge_cnt++;
 249   4      
 250   4                      // pwm_duty = MIN_PWM_DUTY_IN_TRICKLE_CHARGE;
 251   4                      // if (fully_charge_cnt >= 10)
 252   4                      {
 253   5                          // fully_charge_cnt = 0;
 254   5                          pwm_reg = 0;
 255   5                          TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 256   5                          TMR1_PWML = pwm_reg & 0xFF;
 257   5                          timer1_pwm_disable();                             // å·²ç»å……æ»¡ç”µï¼Œæ–­å¼€æ§åˆ¶å……
             -ç”µçš„PWM
 258   5                          cur_charge_phase = CUR_CHARGE_PHASE_FULLY_CHARGE; // è¡¨ç¤ºå·²ç»å……æ»¡ç”µï¼Œæ¥ä¸‹æ¥
             -éœ€è¦ç­‰å……ç”µç”µå‹ä½äº4.0V
 259   5                          cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
 260   5                          return;
 261   5                      }
 262   4      
 263   4                      // real_bat_adc_val = 0; // å¥½åƒå¯ä»¥ä¸åŠ 
 264   4                      // cur_charge_phase = CUR_CHARGE_PHASE_FULLY_CHARGE; // è¡¨ç¤ºå·²ç»å……æ»¡ç”µï¼Œæ¥ä¸‹æ¥é
             -œ€è¦ç­‰å……ç”µç”µå‹ä½äº4.0V
 265   4                      // cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_NONE;
 266   4                      // fully_charge_cnt = 0;
 267   4                  }
 268   3      
 269   3                  return;
 270   3              }
 271   2      
 272   2              // ===================================================================
 273   2              // ä»¥ä¸‹éƒ½æ˜¯æ­£å¸¸å……ç”µå¯¹åº”çš„æ§åˆ¶ç¨‹åºï¼Œcur_charge_phase == CUR_CHARGE_PHASE_NORMAL_CHA
             -RGE
 274   2              // ===================================================================
 275   2      
 276   2              // ä¸æ˜¯æ­£å¸¸å……ç”µï¼Œæå‰è¿”å›
 277   2              if (CUR_CHARGE_PHASE_NORMAL_CHARGE != cur_charge_phase)
 278   2              {
 279   3                  return;
 280   3              }
 281   2      
 282   2              // å¦‚æœPWMæœªåˆ‡æ¢åˆ°é«˜é¢‘
 283   2              if (CUR_CHARGING_PWM_STATUS_HIGH_FRQ != cur_charging_pwm_status)
 284   2              {
 285   3                  pwm_reg = MIN_PWM_DUTY_IN_LOW_POWER;
 286   3                  TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 287   3                  TMR1_PWML = pwm_reg & 0xFF;
 288   3                  timer1_set_pwm_high_feq();
 289   3                  cur_charging_pwm_status = CUR_CHARGING_PWM_STATUS_HIGH_FRQ;
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 6   

 290   3              }
 291   2      
 292   2              adc_update_bat_adc_val();
 293   2              // å¦‚æœç”µæ± ç”µå‹å¤§äº xx Vï¼Œå¼€å§‹é™ä½åŠŸç‡
 294   2              // if (bat_adc_val >= (u16)((u32)3450 * 4096 / 2 / 2 / 1000)) // 3.45Vï¼Œå®é™…æµ‹è¯•æ˜¯åœ¨ 3.38V 
             -é™„è¿‘å¼€å§‹é™ä½åŠŸç‡
 295   2              // if (bat_adc_val >= (u16)((u32)(3500 + 50) * 4096 / 2 / 2 / 1000)) // 3.55Vï¼Œå®é™…æµ‹è¯•åœ¨ 3.
             -48V é™„è¿‘å¼€å§‹é™ä½åŠŸç‡
 296   2              // if (bat_adc_val >= (u16)((u32)(3400) * 4096 / 2 / 2 / 1000)) // åœ¨3.36Vå·¦å³ é™ä½åŠŸç‡ï¼ˆä
             -¸ç¡®å®š3.36Vä»¥ä¸‹æ˜¯å¦å°±å¼€å§‹é™åŠŸç‡ï¼Œå› ä¸ºç”µæ± æ˜¯ä»3.3Vå·¦å³å¼€å§‹å……ç”µï¼‰
 297   2              if (bat_adc_val >= (u16)((u32)(3500 + 50) * 4096 / 2 / 2 / 1000)) //
 298   2              {
 299   3                  // expected_power = 12000;
 300   3                  // expected_power = 10000; // åŠŸç‡å¤ªé«˜ï¼Œä¼šç›´æ¥è·³åˆ°å……æ»¡ç”µçš„é˜¶æ®µï¼ˆè·³åˆ°æ¶“æµå
             -……ç”µï¼Œå†è¿›å…¥å……æ»¡ç”µé˜¶æ®µï¼‰
 301   3                  expected_power = (u16)5000; // å……ç”µé€Ÿåº¦ä¼šå¾ˆæ…¢ï¼Œ1hæ‰æå‡0.01V~0.02V
 302   3              }
 303   2              else if (bat_adc_val >= (u16)((u32)(3400) * 4096 / 2 / 2 / 1000)) //
 304   2              {
 305   3                  expected_power = (u16)26500 / 2;
 306   3              }
 307   2              else // å¦‚æœç”µæ± ç”µå‹å°äº xx Vï¼ŒæŒ‰æ­£å¸¸çš„åŠŸç‡è¿›è¡Œå……ç”µ
 308   2              {
 309   3                  expected_power = (u16)26500;
 310   3              }
 311   2      
 312   2              // adc_sel_ref_voltage(ADC_REF_3_0_VOL);
 313   2              // adc_sel_pin(ADC_PIN_DETECT_CURRENT);
 314   2              // current_adc_val = adc_getval();
 315   2              adc_update_current_adc_val();
 316   2      
 317   2              /*
 318   2                  æ£€æµ‹ç”µæµå¼•è„šæ£€æµ‹åˆ°çš„ç”µå‹ == adå€¼ / 4096 * å‚è€ƒç”µå‹
 319   2                  current_adc_val * 3 / 4096
 320   2      
 321   2                  æ£€æµ‹ç”µæµçš„å¼•è„šæ£€æµ‹åˆ°çš„å……ç”µç”µæµ == æ£€æµ‹ç”µæµå¼•è„šæ£€æµ‹åˆ°çš„ç”µå‹ / 110(è¿
             -æ”¾æ”¾å¤§å€æ•°) / 0.005Rï¼Œ
 322   2                  é€æ­¥æ¢æˆå•ç‰‡æœºå¯ä»¥è®¡ç®—çš„å½¢å¼ï¼š
 323   2                  current_adc_val * 3 / 4096 / 110 / 0.005
 324   2                  current_adc_val * 3 / 4096 / 110 * 1000 / 5
 325   2                  current_adc_val * 3 * 1000 / 5 / 4096 / 110
 326   2                  å¾—åˆ°çš„æ˜¯ä»¥Aä¸ºå•ä½çš„ç”µæµï¼Œéœ€è¦å†è½¬æ¢æˆä»¥mAä¸ºå•ä½ï¼š
 327   2                  current_adc_val * 3 * 1000 * 1000 / 5 / 4096 / 110ï¼Œè®¡ç®—ä¼šæº¢å‡ºï¼Œéœ€è¦å†åŒ–ç®€
 328   2                  (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 110
 329   2                  current =  (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 110;
 330   2              */
 331   2              current = (u32)current_adc_val * 3 * 1000 * (1000 / 5) / 4096 / 76; // è®¡ç®—ç”µæµï¼Œå•ä½ï¼šmA
 332   2      
 333   2              /*
 334   2                  è®¡ç®—å……ç”µç”µå‹
 335   2              */
 336   2              // voltage_of_charging = (u32)charging_adc_val * 3 * 1000 * 11 / 4096;
 337   2              /*
 338   2                  è®¡ç®—ç”µæ± ç”µå‹
 339   2                  ç”µæ± ç”µå‹ï¼ˆmVï¼‰ == é‡‡é›†åˆ°çš„adå€¼ / 4096 * å‚è€ƒç”µå‹ * åˆ†å‹ç³»æ•° * 1000ï¼ˆmVï¼‰
 340   2              */
 341   2              voltage_of_bat = (u32)bat_adc_val * 2 * 1000 * 2 / 4096; // è®¡ç®—ç”µæ± ç”µå‹ï¼Œå•ä½ï¼šmV
 342   2      
 343   2      #if 0
              
                      // if (bat_adc_val >= (u16)((u32)3500 * 4096 / 2 / 2 / 1000))
                      // if (bat_adc_val >= (u16)((u32)3500 * 4096 / 2 / 2 / 1000)) // å®é™…åœ¨ç”µæ± 3.45Vå¼€å§‹å°±è¿›å
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 7   

             -…¥è¿™é‡Œ
                      if (bat_adc_val >= (u16)((u32)3550 * 4096 / 2 / 2 / 1000)) // å®é™…æµ‹è¯•åœ¨ç”µæ± 3.50Vå·¦å³å¼€å
             -§‹è¿›å…¥
                      {
                          // å¼€å§‹æ¶“æµå……ç”µ
                          // limited_current = 100;
                          // if (current > 100)
                          // if (current > 200) // è¶…è¿‡3.55Vä¹‹åï¼Œå¥½åƒä¼šå……ä¸è¿›ç”µ
                          if (current > 400) //
                          // if (current > 800) //
                          {
                              if (pwm_duty > 0)
                              {
                                  pwm_duty--;
                                  // pwm_duty = 0; // åˆšä»æ­£å¸¸å……ç”µå˜ä¸ºæ¶“æµå……ç”µï¼Œå¦‚æœpwmå ç©ºæ¯”æ²¡æœ‰è¿…
             -é€Ÿè°ƒèŠ‚ï¼Œç”µæ± ç”µå‹æœ‰å¯èƒ½ä¼šç›´æ¥è·³åˆ°3.6Vï¼Œè®¤ä¸ºå……æ»¡ç”µ
                              }
                          }
                          // else if (current < 100)
                          // else if (current < 200) // è¶…è¿‡3.55Vä¹‹åï¼Œå¥½åƒä¼šå……ä¸è¿›ç”µ
                          else if (current < 400)
                          // else if (current < 800)
                          {
                              if (pwm_duty < 100) // 100%å ç©ºæ¯”
                              {
                                  pwm_duty++;
                              }
                          }
                      }
                      else // å¦‚æœç”µæ± ç”µå‹ä¸è¶…è¿‡ xx V
              #endif
 375   2              {
 376   3      
 377   3                  // å¦‚æœæ£€æµ‹åˆ°ç”µæµçš„adå€¼å·²ç»çˆ†è¡¨
 378   3                  if (current_adc_val >= 4095)
 379   3                  // if (current >= 5400) // å¦‚æœç”µæµå€¼å·²ç»çˆ†è¡¨ï¼Œè¶…è¿‡å•ç‰‡æœºèƒ½æ£€æµ‹çš„å€¼ï¼ˆç†è
             -®ºå€¼ï¼‰ï¼š5454.54
 380   3                  {
 381   4                      // printf("current overflow\n");
 382   4                      if (pwm_duty > 0)
 383   4                      {
 384   5                          pwm_duty--;
 385   5                      }
 386   4                  }
 387   3                  else //
 388   3                  {
 389   4                      // power = voltage_of_charging * current / 1000; // 1000mV * 1000mA == 1000000 (1 Watt)
 390   4                      // 1000mV * 1000mA == 1000000 (1 Watt)
 391   4                      if (expected_power != 26500)
 392   4                      {
 393   5                          // 0.728Vç”µå‹ï¼Œå¯¹åº”çš„ç”µæµæ˜¯ 1915 mA
 394   5                          if (current < 1916)
 395   5                          {
 396   6                              current = 1;
 397   6                          }
 398   5                      }
 399   4      
 400   4                      power = (u32)voltage_of_bat * current / 1000; // è®¡ç®—åŠŸç‡ï¼Œå•ä½ï¼šæ¯«ç“¦
 401   4      
 402   4                      if (power < expected_power) // å¦‚æœå½“å‰çš„åŠŸç‡ å°äº é™åˆ¶çš„åŠŸç‡
 403   4                      {
 404   5                          if (pwm_duty < 100) // 100%å ç©ºæ¯”
C51 COMPILER V9.60.7.0   CHARGE_HANDLE                                                     07/21/2025 16:51:53 PAGE 8   

 405   5                          {
 406   6                              pwm_duty++;
 407   6                          }
 408   5                      }
 409   4                      else if (power > expected_power) // å¦‚æœå½“å‰çš„åŠŸç‡ å¤§äº é™åˆ¶çš„åŠŸç‡
 410   4                      {
 411   5                          if (pwm_duty > MIN_PWM_DUTY_IN_LOW_POWER) // é˜²æ­¢å‘ä¸‹æº¢å‡º
 412   5                          {
 413   6                              pwm_duty--;
 414   6                          }
 415   5                      }
 416   4                      else // power == ç›®æ ‡å€¼ï¼Œä¸åšè°ƒèŠ‚
 417   4                      {
 418   5                      }
 419   4      
 420   4                      /*
 421   4                          å¦‚æœå·²ç»é™ä½åŠŸç‡ï¼Œæ˜¾ç¤ºæ§åˆ¶å……ç”µçš„pwmå ç©ºæ¯”
 422   4      
 423   4                          æ¥è¿‘æ»¡ç”µæ—¶ï¼Œæµ‹å¾—çš„ç”µæµå€¼å·²ç»ä¸å‡†ç¡®ï¼Œå³ä½¿å•ç‰‡æœºæ§åˆ¶å……ç”µçš„pw
             -mä¸è¾“å‡ºï¼Œæµ‹ç”µæµçš„å¼•è„šä¸Šè¿˜æœ‰0.728Vç”µå‹
 424   4                      */
 425   4                      // if (expected_power < 26500)
 426   4                      // {
 427   4                      //     // é™åˆ¶ä¸º60%ï¼Œæ„Ÿè§‰æ²¡æœ‰èµ·åˆ°æ•ˆæœ
 428   4                      //     // é™åˆ¶ä¸º40%ï¼Œå‘ç°é™åˆ¶å¤ªæ­»ï¼Œè·Ÿæ¶“æµå……ç”µæ²¡æœ‰åŒºåˆ«
 429   4                      //     /*
 430   4                      //         é™åˆ¶ä¸º50%ï¼Œå¦‚æœè¾“å…¥ç”µå‹å¤§äº5Vï¼Œæ‰æœ‰é™æµçš„æ•ˆæœï¼Œ
 431   4                      //         å¦‚æœåœ¨5Vé™„è¿‘ï¼Œå……ç”µç”µæµä¼šåœ¨ 0.8A ~ 0.0xA æ¥å›è·³åŠ¨ï¼Œ
 432   4                      //         æ­¤æ—¶pwmå ç©ºæ¯”å˜åŒ–åº”è¯¥æ˜¯Â±1%ï¼Œåº”è¯¥æ˜¯mosç®¡å¯¼é€šå’Œä¸å¯¼é€šé€ æˆ
             -çš„
 433   4                      //     */
 434   4                      //     if (pwm_duty > (u8)60)
 435   4                      //     {
 436   4                      //         pwm_duty = (u8)60;
 437   4                      //     }
 438   4                      // }
 439   4                  }
 440   3              }
 441   2      
 442   2              // printf("pwm_duty : %bu %%\n", pwm_duty);
 443   2              pwm_reg = (u32)TIMER1_HIGH_FEQ_PEROID_VAL * pwm_duty / 100; // æœ€ç»ˆçš„å ç©ºæ¯”å€¼
 444   2      
 445   2              //     // printf("pwm_duty :%u\n", pwm_duty);
 446   2              TMR1_PWMH = (pwm_reg >> 8) & 0xFF;
 447   2              TMR1_PWML = pwm_reg & 0xFF;
 448   2          }
 449   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    873    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      12
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
